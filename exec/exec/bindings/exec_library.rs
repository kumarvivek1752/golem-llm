// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
// Options used:
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod golem {
    pub mod exec {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod types {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
        pub enum LanguageKind {
          Javascript,
          Python,
        }
        impl ::core::fmt::Debug for LanguageKind {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              LanguageKind::Javascript => {
                f.debug_tuple("LanguageKind::Javascript").finish()
              }
              LanguageKind::Python => {
                f.debug_tuple("LanguageKind::Python").finish()
              }
            }
          }
        }

        impl LanguageKind{
          #[doc(hidden)]
          pub unsafe fn _lift(val: u8) -> LanguageKind{
            if !cfg!(debug_assertions) {
              return unsafe { ::core::mem::transmute(val) };
            }

            match val {
              0 => LanguageKind::Javascript,
              1 => LanguageKind::Python,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        /// Supported language types and optional version
        #[derive(Clone)]
        pub struct Language {
          pub kind: LanguageKind,
          pub version: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for Language {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Language").field("kind", &self.kind).field("version", &self.version).finish()
          }
        }
        /// Supported encodings for file contents
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
        pub enum Encoding {
          Utf8,
          Base64,
          Hex,
        }
        impl ::core::fmt::Debug for Encoding {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Encoding::Utf8 => {
                f.debug_tuple("Encoding::Utf8").finish()
              }
              Encoding::Base64 => {
                f.debug_tuple("Encoding::Base64").finish()
              }
              Encoding::Hex => {
                f.debug_tuple("Encoding::Hex").finish()
              }
            }
          }
        }

        impl Encoding{
          #[doc(hidden)]
          pub unsafe fn _lift(val: u8) -> Encoding{
            if !cfg!(debug_assertions) {
              return unsafe { ::core::mem::transmute(val) };
            }

            match val {
              0 => Encoding::Utf8,
              1 => Encoding::Base64,
              2 => Encoding::Hex,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        /// Code file to execute
        #[derive(Clone)]
        pub struct File {
          pub name: _rt::String,
          pub content: _rt::Vec::<u8>,
          pub encoding: Option<Encoding>,
        }
        impl ::core::fmt::Debug for File {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("File").field("name", &self.name).field("content", &self.content).field("encoding", &self.encoding).finish()
          }
        }
        /// Resource limits and execution constraints
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct Limits {
          pub time_ms: Option<u64>,
          pub memory_bytes: Option<u64>,
          pub file_size_bytes: Option<u64>,
          pub max_processes: Option<u32>,
        }
        impl ::core::fmt::Debug for Limits {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Limits").field("time-ms", &self.time_ms).field("memory-bytes", &self.memory_bytes).field("file-size-bytes", &self.file_size_bytes).field("max-processes", &self.max_processes).finish()
          }
        }
        /// Execution outcome per stage
        #[derive(Clone)]
        pub struct StageResult {
          pub stdout: _rt::String,
          pub stderr: _rt::String,
          pub exit_code: Option<i32>,
          pub signal: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for StageResult {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("StageResult").field("stdout", &self.stdout).field("stderr", &self.stderr).field("exit-code", &self.exit_code).field("signal", &self.signal).finish()
          }
        }
        /// Complete execution exec-result
        #[derive(Clone)]
        pub struct ExecResult {
          pub compile: Option<StageResult>,
          pub run: StageResult,
          pub time_ms: Option<u64>,
          pub memory_bytes: Option<u64>,
        }
        impl ::core::fmt::Debug for ExecResult {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ExecResult").field("compile", &self.compile).field("run", &self.run).field("time-ms", &self.time_ms).field("memory-bytes", &self.memory_bytes).finish()
          }
        }
        /// Execution error types
        #[derive(Clone)]
        pub enum Error {
          UnsupportedLanguage,
          CompilationFailed(StageResult),
          RuntimeFailed(StageResult),
          Timeout,
          ResourceExceeded,
          Internal(_rt::String),
        }
        impl ::core::fmt::Debug for Error {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Error::UnsupportedLanguage => {
                f.debug_tuple("Error::UnsupportedLanguage").finish()
              }
              Error::CompilationFailed(e) => {
                f.debug_tuple("Error::CompilationFailed").field(e).finish()
              }
              Error::RuntimeFailed(e) => {
                f.debug_tuple("Error::RuntimeFailed").field(e).finish()
              }
              Error::Timeout => {
                f.debug_tuple("Error::Timeout").finish()
              }
              Error::ResourceExceeded => {
                f.debug_tuple("Error::ResourceExceeded").finish()
              }
              Error::Internal(e) => {
                f.debug_tuple("Error::Internal").field(e).finish()
              }
            }
          }
        }
        impl ::core::fmt::Display for Error {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "{:?}", self)
          }
        }

        impl std::error::Error for Error {}
        /// Streamed event output during execution
        #[derive(Clone)]
        pub enum ExecEvent {
          StdoutChunk(_rt::Vec::<u8>),
          StderrChunk(_rt::Vec::<u8>),
          Finished(ExecResult),
          Failed(Error),
        }
        impl ::core::fmt::Debug for ExecEvent {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              ExecEvent::StdoutChunk(e) => {
                f.debug_tuple("ExecEvent::StdoutChunk").field(e).finish()
              }
              ExecEvent::StderrChunk(e) => {
                f.debug_tuple("ExecEvent::StderrChunk").field(e).finish()
              }
              ExecEvent::Finished(e) => {
                f.debug_tuple("ExecEvent::Finished").field(e).finish()
              }
              ExecEvent::Failed(e) => {
                f.debug_tuple("ExecEvent::Failed").field(e).finish()
              }
            }
          }
        }
        #[doc(hidden)]

        macro_rules! __export_golem_exec_types_1_0_0_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_golem_exec_types_1_0_0_cabi;

      }


      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod executor {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type Language = super::super::super::super::exports::golem::exec::types::Language;
        pub type File = super::super::super::super::exports::golem::exec::types::File;
        pub type Limits = super::super::super::super::exports::golem::exec::types::Limits;
        pub type ExecResult = super::super::super::super::exports::golem::exec::types::ExecResult;
        pub type Error = super::super::super::super::exports::golem::exec::types::Error;
        pub type ExecEvent = super::super::super::super::exports::golem::exec::types::ExecEvent;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_run_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let result44 = {
          let l0 = i32::from(*arg0.add(0).cast::<u8>());
          let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
          let l5 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l6 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base15 = l5;
          let len15 = l6;
          let mut result15 = _rt::Vec::with_capacity(len15);
          for i in 0..len15 {
            let base = base15.add(i * (5*::core::mem::size_of::<*const u8>()));
            let e15 = {
              let l7 = *base.add(0).cast::<*mut u8>();
              let l8 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
              let l10 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l11 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len12 = l11;
              let l13 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());

              super::super::super::super::exports::golem::exec::types::File{
                name: _rt::string_lift(bytes9),
                content: _rt::Vec::from_raw_parts(l10.cast(), len12, len12),
                encoding: match l13 {
                  0 => None,
                  1 => {
                    let e = {
                      let l14 = i32::from(*base.add(1+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::super::exports::golem::exec::types::Encoding::_lift(l14 as u8)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
              }
            };
            result15.push(e15);
          }
          _rt::cabi_dealloc(base15, len15 * (5*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let l16 = i32::from(*arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>());
          let l20 = *arg0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l21 = *arg0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base25 = l20;
          let len25 = l21;
          let mut result25 = _rt::Vec::with_capacity(len25);
          for i in 0..len25 {
            let base = base25.add(i * (2*::core::mem::size_of::<*const u8>()));
            let e25 = {
              let l22 = *base.add(0).cast::<*mut u8>();
              let l23 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len24 = l23;
              let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

              _rt::string_lift(bytes24)
            };
            result25.push(e25);
          }
          _rt::cabi_dealloc(base25, len25 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let l26 = *arg0.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l27 = *arg0.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base34 = l26;
          let len34 = l27;
          let mut result34 = _rt::Vec::with_capacity(len34);
          for i in 0..len34 {
            let base = base34.add(i * (4*::core::mem::size_of::<*const u8>()));
            let e34 = {
              let l28 = *base.add(0).cast::<*mut u8>();
              let l29 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len30 = l29;
              let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);
              let l31 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l32 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len33 = l32;
              let bytes33 = _rt::Vec::from_raw_parts(l31.cast(), len33, len33);

              (_rt::string_lift(bytes30), _rt::string_lift(bytes33))
            };
            result34.push(e34);
          }
          _rt::cabi_dealloc(base34, len34 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let l35 = i32::from(*arg0.add(8+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
          T::run(super::super::super::super::exports::golem::exec::types::Language{
            kind: super::super::super::super::exports::golem::exec::types::LanguageKind::_lift(l0 as u8),
            version: match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            },
          }, result15, match l16 {
            0 => None,
            1 => {
              let e = {
                let l17 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l18 = *arg0.add(8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len19 = l18;
                let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                _rt::string_lift(bytes19)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }, result25, result34, match l35 {
            0 => None,
            1 => {
              let e = {
                let l36 = i32::from(*arg0.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l38 = i32::from(*arg0.add(32+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l40 = i32::from(*arg0.add(48+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l42 = i32::from(*arg0.add(64+12*::core::mem::size_of::<*const u8>()).cast::<u8>());

                super::super::super::super::exports::golem::exec::types::Limits{
                  time_ms: match l36 {
                    0 => None,
                    1 => {
                      let e = {
                        let l37 = *arg0.add(24+12*::core::mem::size_of::<*const u8>()).cast::<i64>();

                        l37 as u64
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  memory_bytes: match l38 {
                    0 => None,
                    1 => {
                      let e = {
                        let l39 = *arg0.add(40+12*::core::mem::size_of::<*const u8>()).cast::<i64>();

                        l39 as u64
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  file_size_bytes: match l40 {
                    0 => None,
                    1 => {
                      let e = {
                        let l41 = *arg0.add(56+12*::core::mem::size_of::<*const u8>()).cast::<i64>();

                        l41 as u64
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  max_processes: match l42 {
                    0 => None,
                    1 => {
                      let e = {
                        let l43 = *arg0.add(68+12*::core::mem::size_of::<*const u8>()).cast::<i32>();

                        l43 as u32
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          })
        };
        _rt::cabi_dealloc(arg0, 72+12*::core::mem::size_of::<*const u8>(), 8);
        let ptr45 = (&raw mut _RET_AREA.0).cast::<u8>();
        match result44 {
          Ok(e) => { {
            *ptr45.add(0).cast::<u8>() = (0i32) as u8;
            let super::super::super::super::exports::golem::exec::types::ExecResult{ compile:compile46, run:run46, time_ms:time_ms46, memory_bytes:memory_bytes46, } = e;
            match compile46 {
              Some(e) => {
                *ptr45.add(8).cast::<u8>() = (1i32) as u8;
                let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout47, stderr:stderr47, exit_code:exit_code47, signal:signal47, } = e;
                let vec48 = (stdout47.into_bytes()).into_boxed_slice();
                let ptr48 = vec48.as_ptr().cast::<u8>();
                let len48 = vec48.len();
                ::core::mem::forget(vec48);
                *ptr45.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len48;
                *ptr45.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr48.cast_mut();
                let vec49 = (stderr47.into_bytes()).into_boxed_slice();
                let ptr49 = vec49.as_ptr().cast::<u8>();
                let len49 = vec49.len();
                ::core::mem::forget(vec49);
                *ptr45.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len49;
                *ptr45.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr49.cast_mut();
                match exit_code47 {
                  Some(e) => {
                    *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr45.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                  },
                  None => {
                    {
                      *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match signal47 {
                  Some(e) => {
                    *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec50 = (e.into_bytes()).into_boxed_slice();
                    let ptr50 = vec50.as_ptr().cast::<u8>();
                    let len50 = vec50.len();
                    ::core::mem::forget(vec50);
                    *ptr45.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len50;
                    *ptr45.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr50.cast_mut();
                  },
                  None => {
                    {
                      *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr45.add(8).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout51, stderr:stderr51, exit_code:exit_code51, signal:signal51, } = run46;
              let vec52 = (stdout51.into_bytes()).into_boxed_slice();
              let ptr52 = vec52.as_ptr().cast::<u8>();
              let len52 = vec52.len();
              ::core::mem::forget(vec52);
              *ptr45.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len52;
              *ptr45.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr52.cast_mut();
              let vec53 = (stderr51.into_bytes()).into_boxed_slice();
              let ptr53 = vec53.as_ptr().cast::<u8>();
              let len53 = vec53.len();
              ::core::mem::forget(vec53);
              *ptr45.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len53;
              *ptr45.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr53.cast_mut();
              match exit_code51 {
                Some(e) => {
                  *ptr45.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr45.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                },
                None => {
                  {
                    *ptr45.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match signal51 {
                Some(e) => {
                  *ptr45.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec54 = (e.into_bytes()).into_boxed_slice();
                  let ptr54 = vec54.as_ptr().cast::<u8>();
                  let len54 = vec54.len();
                  ::core::mem::forget(vec54);
                  *ptr45.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len54;
                  *ptr45.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr54.cast_mut();
                },
                None => {
                  {
                    *ptr45.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match time_ms46 {
                Some(e) => {
                  *ptr45.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr45.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *ptr45.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match memory_bytes46 {
                Some(e) => {
                  *ptr45.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr45.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *ptr45.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };} },
              Err(e) => { {
                *ptr45.add(0).cast::<u8>() = (1i32) as u8;
                use super::super::super::super::exports::golem::exec::types::Error as V64;
                match e {
                  V64::UnsupportedLanguage=> {
                    {
                      *ptr45.add(8).cast::<u8>() = (0i32) as u8;
                    }
                  }
                  V64::CompilationFailed(e) => {
                    *ptr45.add(8).cast::<u8>() = (1i32) as u8;
                    let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout55, stderr:stderr55, exit_code:exit_code55, signal:signal55, } = e;
                    let vec56 = (stdout55.into_bytes()).into_boxed_slice();
                    let ptr56 = vec56.as_ptr().cast::<u8>();
                    let len56 = vec56.len();
                    ::core::mem::forget(vec56);
                    *ptr45.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len56;
                    *ptr45.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr56.cast_mut();
                    let vec57 = (stderr55.into_bytes()).into_boxed_slice();
                    let ptr57 = vec57.as_ptr().cast::<u8>();
                    let len57 = vec57.len();
                    ::core::mem::forget(vec57);
                    *ptr45.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len57;
                    *ptr45.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr57.cast_mut();
                    match exit_code55 {
                      Some(e) => {
                        *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *ptr45.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                      },
                      None => {
                        {
                          *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match signal55 {
                      Some(e) => {
                        *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec58 = (e.into_bytes()).into_boxed_slice();
                        let ptr58 = vec58.as_ptr().cast::<u8>();
                        let len58 = vec58.len();
                        ::core::mem::forget(vec58);
                        *ptr45.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len58;
                        *ptr45.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr58.cast_mut();
                      },
                      None => {
                        {
                          *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };},
                    V64::RuntimeFailed(e) => {
                      *ptr45.add(8).cast::<u8>() = (2i32) as u8;
                      let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout59, stderr:stderr59, exit_code:exit_code59, signal:signal59, } = e;
                      let vec60 = (stdout59.into_bytes()).into_boxed_slice();
                      let ptr60 = vec60.as_ptr().cast::<u8>();
                      let len60 = vec60.len();
                      ::core::mem::forget(vec60);
                      *ptr45.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len60;
                      *ptr45.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr60.cast_mut();
                      let vec61 = (stderr59.into_bytes()).into_boxed_slice();
                      let ptr61 = vec61.as_ptr().cast::<u8>();
                      let len61 = vec61.len();
                      ::core::mem::forget(vec61);
                      *ptr45.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len61;
                      *ptr45.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr61.cast_mut();
                      match exit_code59 {
                        Some(e) => {
                          *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr45.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                        },
                        None => {
                          {
                            *ptr45.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match signal59 {
                        Some(e) => {
                          *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec62 = (e.into_bytes()).into_boxed_slice();
                          let ptr62 = vec62.as_ptr().cast::<u8>();
                          let len62 = vec62.len();
                          ::core::mem::forget(vec62);
                          *ptr45.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len62;
                          *ptr45.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr62.cast_mut();
                        },
                        None => {
                          {
                            *ptr45.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      V64::Timeout=> {
                        {
                          *ptr45.add(8).cast::<u8>() = (3i32) as u8;
                        }
                      }
                      V64::ResourceExceeded=> {
                        {
                          *ptr45.add(8).cast::<u8>() = (4i32) as u8;
                        }
                      }
                      V64::Internal(e) => {
                        *ptr45.add(8).cast::<u8>() = (5i32) as u8;
                        let vec63 = (e.into_bytes()).into_boxed_slice();
                        let ptr63 = vec63.as_ptr().cast::<u8>();
                        let len63 = vec63.len();
                        ::core::mem::forget(vec63);
                        *ptr45.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len63;
                        *ptr45.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr63.cast_mut();
                      },
                    }
                  } },
                };ptr45
              } }
              #[doc(hidden)]
              #[allow(non_snake_case)]
              pub unsafe fn __post_return_run<T: Guest>(arg0: *mut u8,) { unsafe {
                let l0 = i32::from(*arg0.add(0).cast::<u8>());
                match l0 {
                  0 => {
                    let l1 = i32::from(*arg0.add(8).cast::<u8>());
                    match l1 {
                      0 => (),
                      _ => {
                        let l2 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l3 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l2, l3, 1);
                        let l4 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l4, l5, 1);
                        let l6 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l6 {
                          0 => (),
                          _ => {
                            let l7 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l8 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                          },
                        }
                      },
                    }
                    let l9 = *arg0.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l10 = *arg0.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l9, l10, 1);
                    let l11 = *arg0.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l12 = *arg0.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l11, l12, 1);
                    let l13 = i32::from(*arg0.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l13 {
                      0 => (),
                      _ => {
                        let l14 = *arg0.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l15 = *arg0.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l14, l15, 1);
                      },
                    }
                  },
                  _ => {
                    let l16 = i32::from(*arg0.add(8).cast::<u8>());
                    match l16 {
                      0 => (),
                      1 => {
                        let l17 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l18 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l17, l18, 1);
                        let l19 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l20 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l19, l20, 1);
                        let l21 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l21 {
                          0 => (),
                          _ => {
                            let l22 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l23 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l22, l23, 1);
                          },
                        }
                      },
                      2 => {
                        let l24 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l25 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l24, l25, 1);
                        let l26 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l27 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l26, l27, 1);
                        let l28 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l28 {
                          0 => (),
                          _ => {
                            let l29 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l30 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l29, l30, 1);
                          },
                        }
                      },
                      3 => (),
                      4 => (),
                      _ => {
                        let l31 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l32 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l31, l32, 1);
                      },
                    }
                  },
                }
              } }
              #[doc(hidden)]
              #[allow(non_snake_case, unused_unsafe)]
              pub unsafe fn _export_run_streaming_cabi<T: Guest>(arg0: *mut u8,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
              _rt::run_ctors_once();let result42 = {
                let l0 = i32::from(*arg0.add(0).cast::<u8>());
                let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l5 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base15 = l5;
                let len15 = l6;
                let mut result15 = _rt::Vec::with_capacity(len15);
                for i in 0..len15 {
                  let base = base15.add(i * (5*::core::mem::size_of::<*const u8>()));
                  let e15 = {
                    let l7 = *base.add(0).cast::<*mut u8>();
                    let l8 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l11 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len12 = l11;
                    let l13 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                    super::super::super::super::exports::golem::exec::types::File{
                      name: _rt::string_lift(bytes9),
                      content: _rt::Vec::from_raw_parts(l10.cast(), len12, len12),
                      encoding: match l13 {
                        0 => None,
                        1 => {
                          let e = {
                            let l14 = i32::from(*base.add(1+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                            super::super::super::super::exports::golem::exec::types::Encoding::_lift(l14 as u8)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      },
                    }
                  };
                  result15.push(e15);
                }
                _rt::cabi_dealloc(base15, len15 * (5*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let l16 = i32::from(*arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l18 = *arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l19 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base23 = l18;
                let len23 = l19;
                let mut result23 = _rt::Vec::with_capacity(len23);
                for i in 0..len23 {
                  let base = base23.add(i * (2*::core::mem::size_of::<*const u8>()));
                  let e23 = {
                    let l20 = *base.add(0).cast::<*mut u8>();
                    let l21 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len22 = l21;
                    let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);

                    _rt::string_lift(bytes22)
                  };
                  result23.push(e23);
                }
                _rt::cabi_dealloc(base23, len23 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let l24 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l25 = *arg0.add(8+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base32 = l24;
                let len32 = l25;
                let mut result32 = _rt::Vec::with_capacity(len32);
                for i in 0..len32 {
                  let base = base32.add(i * (4*::core::mem::size_of::<*const u8>()));
                  let e32 = {
                    let l26 = *base.add(0).cast::<*mut u8>();
                    let l27 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len28 = l27;
                    let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);
                    let l29 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l30 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len31 = l30;
                    let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                    (_rt::string_lift(bytes28), _rt::string_lift(bytes31))
                  };
                  result32.push(e32);
                }
                _rt::cabi_dealloc(base32, len32 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let l33 = i32::from(*arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                T::run_streaming(super::super::super::super::exports::golem::exec::types::Language{
                  kind: super::super::super::super::exports::golem::exec::types::LanguageKind::_lift(l0 as u8),
                  version: match l1 {
                    0 => None,
                    1 => {
                      let e = {
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                        _rt::string_lift(bytes4)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }, result15, match l16 {
                  0 => None,
                  1 => {
                    let e = {
                      let l17 = *arg0.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>();

                      wit_bindgen::rt::async_support::StreamReader::new(l17 as u32, &super::super::super::super::wit_stream::vtable0::VTABLE)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }, result23, result32, match l33 {
                  0 => None,
                  1 => {
                    let e = {
                      let l34 = i32::from(*arg0.add(16+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l36 = i32::from(*arg0.add(32+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l38 = i32::from(*arg0.add(48+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l40 = i32::from(*arg0.add(64+10*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::super::exports::golem::exec::types::Limits{
                        time_ms: match l34 {
                          0 => None,
                          1 => {
                            let e = {
                              let l35 = *arg0.add(24+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                              l35 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        memory_bytes: match l36 {
                          0 => None,
                          1 => {
                            let e = {
                              let l37 = *arg0.add(40+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                              l37 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        file_size_bytes: match l38 {
                          0 => None,
                          1 => {
                            let e = {
                              let l39 = *arg0.add(56+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                              l39 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        max_processes: match l40 {
                          0 => None,
                          1 => {
                            let e = {
                              let l41 = *arg0.add(68+10*::core::mem::size_of::<*const u8>()).cast::<i32>();

                              l41 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                })
              };
              _rt::cabi_dealloc(arg0, 72+10*::core::mem::size_of::<*const u8>(), 8);
              (result42).take_handle() as i32
            } }
            pub trait Guest {
              /// Blocking, non-streaming execution
              #[allow(async_fn_in_trait)]
              fn run(lang: Language,files: _rt::Vec::<File>,stdin: Option<_rt::String>,args: _rt::Vec::<_rt::String>,env: _rt::Vec::<(_rt::String,_rt::String,)>,constraints: Option<Limits>,) -> Result<ExecResult,Error>;
              /// Streaming execution with bidirectional I/O
              #[allow(async_fn_in_trait)]
              fn run_streaming(lang: Language,files: _rt::Vec::<File>,stdin: Option<wit_bindgen::rt::async_support::StreamReader<_rt::Vec::<u8>>>,args: _rt::Vec::<_rt::String>,env: _rt::Vec::<(_rt::String,_rt::String,)>,constraints: Option<Limits>,) -> wit_bindgen::rt::async_support::StreamReader<ExecEvent>;
            }
            #[doc(hidden)]

            macro_rules! __export_golem_exec_executor_1_0_0_cabi{
              ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

                #[unsafe(export_name = "golem:exec/executor@1.0.0#run")]
                unsafe extern "C" fn export_run(arg0: *mut u8,) -> *mut u8 {
                  unsafe { $($path_to_types)*::_export_run_cabi::<$ty>(arg0) }
                }
                #[unsafe(export_name = "cabi_post_golem:exec/executor@1.0.0#run")]
                unsafe extern "C" fn _post_return_run(arg0: *mut u8,) {
                  unsafe { $($path_to_types)*::__post_return_run::<$ty>(arg0) }
                }
                #[unsafe(export_name = "golem:exec/executor@1.0.0#run-streaming")]
                unsafe extern "C" fn export_run_streaming(arg0: *mut u8,) -> i32 {
                  unsafe { $($path_to_types)*::_export_run_streaming_cabi::<$ty>(arg0) }
                }
              };);
            }
            #[doc(hidden)]
            pub(crate) use __export_golem_exec_executor_1_0_0_cabi;

            #[repr(align(8))]
            struct _RetArea([::core::mem::MaybeUninit::<u8>; 64+14*::core::mem::size_of::<*const u8>()]);
            static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 64+14*::core::mem::size_of::<*const u8>()]);

          }


          #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
          pub mod session {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() =
            super::super::super::super::__link_custom_section_describing_imports;
            
            use super::super::super::super::_rt;
            pub type Language = super::super::super::super::exports::golem::exec::types::Language;
            pub type File = super::super::super::super::exports::golem::exec::types::File;
            pub type Limits = super::super::super::super::exports::golem::exec::types::Limits;
            pub type ExecResult = super::super::super::super::exports::golem::exec::types::ExecResult;
            pub type Error = super::super::super::super::exports::golem::exec::types::Error;
            pub type ExecEvent = super::super::super::super::exports::golem::exec::types::ExecEvent;
            /// Session handle type
            pub type SessionHandle = u32;
            #[doc(hidden)]
            #[allow(non_snake_case, unused_unsafe)]
            pub unsafe fn _export_create_cabi<T: Guest>(arg0: i32,arg1: i32,arg2: *mut u8,arg3: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
            _rt::run_ctors_once();let result1 = {
              T::create(super::super::super::super::exports::golem::exec::types::Language{
                kind: super::super::super::super::exports::golem::exec::types::LanguageKind::_lift(arg0 as u8),
                version: match arg1 {
                  0 => None,
                  1 => {
                    let e = {
                      let len0 = arg3;
                      let bytes0 = _rt::Vec::from_raw_parts(arg2.cast(), len0, len0);

                      _rt::string_lift(bytes0)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
              })
            };
            let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
            match result1 {
              Ok(e) => { {
                *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
              } },
              Err(e) => { {
                *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                use super::super::super::super::exports::golem::exec::types::Error as V12;
                match e {
                  V12::UnsupportedLanguage=> {
                    {
                      *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  }
                  V12::CompilationFailed(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout3, stderr:stderr3, exit_code:exit_code3, signal:signal3, } = e;
                    let vec4 = (stdout3.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (stderr3.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                    match exit_code3 {
                      Some(e) => {
                        *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                      },
                      None => {
                        {
                          *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match signal3 {
                      Some(e) => {
                        *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec6 = (e.into_bytes()).into_boxed_slice();
                        let ptr6 = vec6.as_ptr().cast::<u8>();
                        let len6 = vec6.len();
                        ::core::mem::forget(vec6);
                        *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                        *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                      },
                      None => {
                        {
                          *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };},
                    V12::RuntimeFailed(e) => {
                      *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                      let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout7, stderr:stderr7, exit_code:exit_code7, signal:signal7, } = e;
                      let vec8 = (stdout7.into_bytes()).into_boxed_slice();
                      let ptr8 = vec8.as_ptr().cast::<u8>();
                      let len8 = vec8.len();
                      ::core::mem::forget(vec8);
                      *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                      *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                      let vec9 = (stderr7.into_bytes()).into_boxed_slice();
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      ::core::mem::forget(vec9);
                      *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                      *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                      match exit_code7 {
                        Some(e) => {
                          *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                        },
                        None => {
                          {
                            *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match signal7 {
                        Some(e) => {
                          *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec10 = (e.into_bytes()).into_boxed_slice();
                          let ptr10 = vec10.as_ptr().cast::<u8>();
                          let len10 = vec10.len();
                          ::core::mem::forget(vec10);
                          *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                          *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                        },
                        None => {
                          {
                            *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      V12::Timeout=> {
                        {
                          *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                        }
                      }
                      V12::ResourceExceeded=> {
                        {
                          *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                        }
                      }
                      V12::Internal(e) => {
                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                        let vec11 = (e.into_bytes()).into_boxed_slice();
                        let ptr11 = vec11.as_ptr().cast::<u8>();
                        let len11 = vec11.len();
                        ::core::mem::forget(vec11);
                        *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                        *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                      },
                    }
                  } },
                };ptr2
              } }
              #[doc(hidden)]
              #[allow(non_snake_case)]
              pub unsafe fn __post_return_create<T: Guest>(arg0: *mut u8,) { unsafe {
                let l0 = i32::from(*arg0.add(0).cast::<u8>());
                match l0 {
                  0 => (),
                  _ => {
                    let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l1 {
                      0 => (),
                      1 => {
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l2, l3, 1);
                        let l4 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l4, l5, 1);
                        let l6 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l6 {
                          0 => (),
                          _ => {
                            let l7 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l8 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                          },
                        }
                      },
                      2 => {
                        let l9 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l10 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l9, l10, 1);
                        let l11 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l12 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l11, l12, 1);
                        let l13 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l13 {
                          0 => (),
                          _ => {
                            let l14 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l15 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l14, l15, 1);
                          },
                        }
                      },
                      3 => (),
                      4 => (),
                      _ => {
                        let l16 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l17 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l16, l17, 1);
                      },
                    }
                  },
                }
              } }
              #[doc(hidden)]
              #[allow(non_snake_case, unused_unsafe)]
              pub unsafe fn _export_upload_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,arg3: *mut u8,arg4: usize,arg5: i32,arg6: i32,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
              _rt::run_ctors_once();let result2 = {
                let len0 = arg2;
                let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                let len1 = arg4;
                T::upload(arg0 as u32, super::super::super::super::exports::golem::exec::types::File{
                  name: _rt::string_lift(bytes0),
                  content: _rt::Vec::from_raw_parts(arg3.cast(), len1, len1),
                  encoding: match arg5 {
                    0 => None,
                    1 => {
                      let e = super::super::super::super::exports::golem::exec::types::Encoding::_lift(arg6 as u8);
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                })
              };
              let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
              match result2 {
                Ok(_) => { {
                  *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                } },
                Err(e) => { {
                  *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                  use super::super::super::super::exports::golem::exec::types::Error as V13;
                  match e {
                    V13::UnsupportedLanguage=> {
                      {
                        *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    }
                    V13::CompilationFailed(e) => {
                      *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout4, stderr:stderr4, exit_code:exit_code4, signal:signal4, } = e;
                      let vec5 = (stdout4.into_bytes()).into_boxed_slice();
                      let ptr5 = vec5.as_ptr().cast::<u8>();
                      let len5 = vec5.len();
                      ::core::mem::forget(vec5);
                      *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                      *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                      let vec6 = (stderr4.into_bytes()).into_boxed_slice();
                      let ptr6 = vec6.as_ptr().cast::<u8>();
                      let len6 = vec6.len();
                      ::core::mem::forget(vec6);
                      *ptr3.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                      *ptr3.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                      match exit_code4 {
                        Some(e) => {
                          *ptr3.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr3.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                        },
                        None => {
                          {
                            *ptr3.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match signal4 {
                        Some(e) => {
                          *ptr3.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec7 = (e.into_bytes()).into_boxed_slice();
                          let ptr7 = vec7.as_ptr().cast::<u8>();
                          let len7 = vec7.len();
                          ::core::mem::forget(vec7);
                          *ptr3.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                          *ptr3.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                        },
                        None => {
                          {
                            *ptr3.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      V13::RuntimeFailed(e) => {
                        *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                        let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout8, stderr:stderr8, exit_code:exit_code8, signal:signal8, } = e;
                        let vec9 = (stdout8.into_bytes()).into_boxed_slice();
                        let ptr9 = vec9.as_ptr().cast::<u8>();
                        let len9 = vec9.len();
                        ::core::mem::forget(vec9);
                        *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                        *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                        let vec10 = (stderr8.into_bytes()).into_boxed_slice();
                        let ptr10 = vec10.as_ptr().cast::<u8>();
                        let len10 = vec10.len();
                        ::core::mem::forget(vec10);
                        *ptr3.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                        *ptr3.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                        match exit_code8 {
                          Some(e) => {
                            *ptr3.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            *ptr3.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                          },
                          None => {
                            {
                              *ptr3.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match signal8 {
                          Some(e) => {
                            *ptr3.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec11 = (e.into_bytes()).into_boxed_slice();
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            ::core::mem::forget(vec11);
                            *ptr3.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                            *ptr3.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                          },
                          None => {
                            {
                              *ptr3.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        V13::Timeout=> {
                          {
                            *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                          }
                        }
                        V13::ResourceExceeded=> {
                          {
                            *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                          }
                        }
                        V13::Internal(e) => {
                          *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                          let vec12 = (e.into_bytes()).into_boxed_slice();
                          let ptr12 = vec12.as_ptr().cast::<u8>();
                          let len12 = vec12.len();
                          ::core::mem::forget(vec12);
                          *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                          *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                        },
                      }
                    } },
                  };ptr3
                } }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_upload<T: Guest>(arg0: *mut u8,) { unsafe {
                  let l0 = i32::from(*arg0.add(0).cast::<u8>());
                  match l0 {
                    0 => (),
                    _ => {
                      let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                      match l1 {
                        0 => (),
                        1 => {
                          let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          _rt::cabi_dealloc(l2, l3, 1);
                          let l4 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l5 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          _rt::cabi_dealloc(l4, l5, 1);
                          let l6 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          match l6 {
                            0 => (),
                            _ => {
                              let l7 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l8 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              _rt::cabi_dealloc(l7, l8, 1);
                            },
                          }
                        },
                        2 => {
                          let l9 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l10 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          _rt::cabi_dealloc(l9, l10, 1);
                          let l11 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l12 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          _rt::cabi_dealloc(l11, l12, 1);
                          let l13 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          match l13 {
                            0 => (),
                            _ => {
                              let l14 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l15 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              _rt::cabi_dealloc(l14, l15, 1);
                            },
                          }
                        },
                        3 => (),
                        4 => (),
                        _ => {
                          let l16 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l17 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          _rt::cabi_dealloc(l16, l17, 1);
                        },
                      }
                    },
                  }
                } }
                #[doc(hidden)]
                #[allow(non_snake_case, unused_unsafe)]
                pub unsafe fn _export_run_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                _rt::run_ctors_once();let result32 = {
                  let l0 = *arg0.add(0).cast::<i32>();
                  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len3 = l2;
                  let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                  let l4 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l5 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base9 = l4;
                  let len9 = l5;
                  let mut result9 = _rt::Vec::with_capacity(len9);
                  for i in 0..len9 {
                    let base = base9.add(i * (2*::core::mem::size_of::<*const u8>()));
                    let e9 = {
                      let l6 = *base.add(0).cast::<*mut u8>();
                      let l7 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len8 = l7;
                      let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

                      _rt::string_lift(bytes8)
                    };
                    result9.push(e9);
                  }
                  _rt::cabi_dealloc(base9, len9 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let l10 = i32::from(*arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l14 = *arg0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l15 = *arg0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base22 = l14;
                  let len22 = l15;
                  let mut result22 = _rt::Vec::with_capacity(len22);
                  for i in 0..len22 {
                    let base = base22.add(i * (4*::core::mem::size_of::<*const u8>()));
                    let e22 = {
                      let l16 = *base.add(0).cast::<*mut u8>();
                      let l17 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len18 = l17;
                      let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);
                      let l19 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l20 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len21 = l20;
                      let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                      (_rt::string_lift(bytes18), _rt::string_lift(bytes21))
                    };
                    result22.push(e22);
                  }
                  _rt::cabi_dealloc(base22, len22 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let l23 = i32::from(*arg0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  T::run(l0 as u32, _rt::string_lift(bytes3), result9, match l10 {
                    0 => None,
                    1 => {
                      let e = {
                        let l11 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l12 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len13 = l12;
                        let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                        _rt::string_lift(bytes13)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }, result22, match l23 {
                    0 => None,
                    1 => {
                      let e = {
                        let l24 = i32::from(*arg0.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l26 = i32::from(*arg0.add(24+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l28 = i32::from(*arg0.add(40+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l30 = i32::from(*arg0.add(56+10*::core::mem::size_of::<*const u8>()).cast::<u8>());

                        super::super::super::super::exports::golem::exec::types::Limits{
                          time_ms: match l24 {
                            0 => None,
                            1 => {
                              let e = {
                                let l25 = *arg0.add(16+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                l25 as u64
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          memory_bytes: match l26 {
                            0 => None,
                            1 => {
                              let e = {
                                let l27 = *arg0.add(32+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                l27 as u64
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          file_size_bytes: match l28 {
                            0 => None,
                            1 => {
                              let e = {
                                let l29 = *arg0.add(48+10*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                l29 as u64
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          max_processes: match l30 {
                            0 => None,
                            1 => {
                              let e = {
                                let l31 = *arg0.add(60+10*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                l31 as u32
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  })
                };
                _rt::cabi_dealloc(arg0, 64+10*::core::mem::size_of::<*const u8>(), 8);
                let ptr33 = (&raw mut _RET_AREA.0).cast::<u8>();
                match result32 {
                  Ok(e) => { {
                    *ptr33.add(0).cast::<u8>() = (0i32) as u8;
                    let super::super::super::super::exports::golem::exec::types::ExecResult{ compile:compile34, run:run34, time_ms:time_ms34, memory_bytes:memory_bytes34, } = e;
                    match compile34 {
                      Some(e) => {
                        *ptr33.add(8).cast::<u8>() = (1i32) as u8;
                        let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout35, stderr:stderr35, exit_code:exit_code35, signal:signal35, } = e;
                        let vec36 = (stdout35.into_bytes()).into_boxed_slice();
                        let ptr36 = vec36.as_ptr().cast::<u8>();
                        let len36 = vec36.len();
                        ::core::mem::forget(vec36);
                        *ptr33.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len36;
                        *ptr33.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr36.cast_mut();
                        let vec37 = (stderr35.into_bytes()).into_boxed_slice();
                        let ptr37 = vec37.as_ptr().cast::<u8>();
                        let len37 = vec37.len();
                        ::core::mem::forget(vec37);
                        *ptr33.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len37;
                        *ptr33.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr37.cast_mut();
                        match exit_code35 {
                          Some(e) => {
                            *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            *ptr33.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                          },
                          None => {
                            {
                              *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match signal35 {
                          Some(e) => {
                            *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec38 = (e.into_bytes()).into_boxed_slice();
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            ::core::mem::forget(vec38);
                            *ptr33.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len38;
                            *ptr33.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr38.cast_mut();
                          },
                          None => {
                            {
                              *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        None => {
                          {
                            *ptr33.add(8).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout39, stderr:stderr39, exit_code:exit_code39, signal:signal39, } = run34;
                      let vec40 = (stdout39.into_bytes()).into_boxed_slice();
                      let ptr40 = vec40.as_ptr().cast::<u8>();
                      let len40 = vec40.len();
                      ::core::mem::forget(vec40);
                      *ptr33.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len40;
                      *ptr33.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr40.cast_mut();
                      let vec41 = (stderr39.into_bytes()).into_boxed_slice();
                      let ptr41 = vec41.as_ptr().cast::<u8>();
                      let len41 = vec41.len();
                      ::core::mem::forget(vec41);
                      *ptr33.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len41;
                      *ptr33.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr41.cast_mut();
                      match exit_code39 {
                        Some(e) => {
                          *ptr33.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr33.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                        },
                        None => {
                          {
                            *ptr33.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match signal39 {
                        Some(e) => {
                          *ptr33.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec42 = (e.into_bytes()).into_boxed_slice();
                          let ptr42 = vec42.as_ptr().cast::<u8>();
                          let len42 = vec42.len();
                          ::core::mem::forget(vec42);
                          *ptr33.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len42;
                          *ptr33.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr42.cast_mut();
                        },
                        None => {
                          {
                            *ptr33.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match time_ms34 {
                        Some(e) => {
                          *ptr33.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr33.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                        },
                        None => {
                          {
                            *ptr33.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match memory_bytes34 {
                        Some(e) => {
                          *ptr33.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr33.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                        },
                        None => {
                          {
                            *ptr33.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };} },
                      Err(e) => { {
                        *ptr33.add(0).cast::<u8>() = (1i32) as u8;
                        use super::super::super::super::exports::golem::exec::types::Error as V52;
                        match e {
                          V52::UnsupportedLanguage=> {
                            {
                              *ptr33.add(8).cast::<u8>() = (0i32) as u8;
                            }
                          }
                          V52::CompilationFailed(e) => {
                            *ptr33.add(8).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout43, stderr:stderr43, exit_code:exit_code43, signal:signal43, } = e;
                            let vec44 = (stdout43.into_bytes()).into_boxed_slice();
                            let ptr44 = vec44.as_ptr().cast::<u8>();
                            let len44 = vec44.len();
                            ::core::mem::forget(vec44);
                            *ptr33.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len44;
                            *ptr33.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr44.cast_mut();
                            let vec45 = (stderr43.into_bytes()).into_boxed_slice();
                            let ptr45 = vec45.as_ptr().cast::<u8>();
                            let len45 = vec45.len();
                            ::core::mem::forget(vec45);
                            *ptr33.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len45;
                            *ptr33.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr45.cast_mut();
                            match exit_code43 {
                              Some(e) => {
                                *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                *ptr33.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                              },
                              None => {
                                {
                                  *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };match signal43 {
                              Some(e) => {
                                *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let vec46 = (e.into_bytes()).into_boxed_slice();
                                let ptr46 = vec46.as_ptr().cast::<u8>();
                                let len46 = vec46.len();
                                ::core::mem::forget(vec46);
                                *ptr33.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len46;
                                *ptr33.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr46.cast_mut();
                              },
                              None => {
                                {
                                  *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };},
                            V52::RuntimeFailed(e) => {
                              *ptr33.add(8).cast::<u8>() = (2i32) as u8;
                              let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout47, stderr:stderr47, exit_code:exit_code47, signal:signal47, } = e;
                              let vec48 = (stdout47.into_bytes()).into_boxed_slice();
                              let ptr48 = vec48.as_ptr().cast::<u8>();
                              let len48 = vec48.len();
                              ::core::mem::forget(vec48);
                              *ptr33.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len48;
                              *ptr33.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr48.cast_mut();
                              let vec49 = (stderr47.into_bytes()).into_boxed_slice();
                              let ptr49 = vec49.as_ptr().cast::<u8>();
                              let len49 = vec49.len();
                              ::core::mem::forget(vec49);
                              *ptr33.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len49;
                              *ptr33.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr49.cast_mut();
                              match exit_code47 {
                                Some(e) => {
                                  *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  *ptr33.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                },
                                None => {
                                  {
                                    *ptr33.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };match signal47 {
                                Some(e) => {
                                  *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  let vec50 = (e.into_bytes()).into_boxed_slice();
                                  let ptr50 = vec50.as_ptr().cast::<u8>();
                                  let len50 = vec50.len();
                                  ::core::mem::forget(vec50);
                                  *ptr33.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len50;
                                  *ptr33.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr50.cast_mut();
                                },
                                None => {
                                  {
                                    *ptr33.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };},
                              V52::Timeout=> {
                                {
                                  *ptr33.add(8).cast::<u8>() = (3i32) as u8;
                                }
                              }
                              V52::ResourceExceeded=> {
                                {
                                  *ptr33.add(8).cast::<u8>() = (4i32) as u8;
                                }
                              }
                              V52::Internal(e) => {
                                *ptr33.add(8).cast::<u8>() = (5i32) as u8;
                                let vec51 = (e.into_bytes()).into_boxed_slice();
                                let ptr51 = vec51.as_ptr().cast::<u8>();
                                let len51 = vec51.len();
                                ::core::mem::forget(vec51);
                                *ptr33.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len51;
                                *ptr33.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr51.cast_mut();
                              },
                            }
                          } },
                        };ptr33
                      } }
                      #[doc(hidden)]
                      #[allow(non_snake_case)]
                      pub unsafe fn __post_return_run<T: Guest>(arg0: *mut u8,) { unsafe {
                        let l0 = i32::from(*arg0.add(0).cast::<u8>());
                        match l0 {
                          0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                              0 => (),
                              _ => {
                                let l2 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l3 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l2, l3, 1);
                                let l4 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l5 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l4, l5, 1);
                                let l6 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l6 {
                                  0 => (),
                                  _ => {
                                    let l7 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l8 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                  },
                                }
                              },
                            }
                            let l9 = *arg0.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l10 = *arg0.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l9, l10, 1);
                            let l11 = *arg0.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l12 = *arg0.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l11, l12, 1);
                            let l13 = i32::from(*arg0.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            match l13 {
                              0 => (),
                              _ => {
                                let l14 = *arg0.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l15 = *arg0.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l14, l15, 1);
                              },
                            }
                          },
                          _ => {
                            let l16 = i32::from(*arg0.add(8).cast::<u8>());
                            match l16 {
                              0 => (),
                              1 => {
                                let l17 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l18 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l17, l18, 1);
                                let l19 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l20 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l19, l20, 1);
                                let l21 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l21 {
                                  0 => (),
                                  _ => {
                                    let l22 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l23 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                  },
                                }
                              },
                              2 => {
                                let l24 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l25 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l24, l25, 1);
                                let l26 = *arg0.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l27 = *arg0.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l26, l27, 1);
                                let l28 = i32::from(*arg0.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l28 {
                                  0 => (),
                                  _ => {
                                    let l29 = *arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l30 = *arg0.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                  },
                                }
                              },
                              3 => (),
                              4 => (),
                              _ => {
                                let l31 = *arg0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l32 = *arg0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l31, l32, 1);
                              },
                            }
                          },
                        }
                      } }
                      #[doc(hidden)]
                      #[allow(non_snake_case, unused_unsafe)]
                      pub unsafe fn _export_run_streaming_cabi<T: Guest>(arg0: *mut u8,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
                      _rt::run_ctors_once();let result30 = {
                        let l0 = *arg0.add(0).cast::<i32>();
                        let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len3 = l2;
                        let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                        let l4 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let base9 = l4;
                        let len9 = l5;
                        let mut result9 = _rt::Vec::with_capacity(len9);
                        for i in 0..len9 {
                          let base = base9.add(i * (2*::core::mem::size_of::<*const u8>()));
                          let e9 = {
                            let l6 = *base.add(0).cast::<*mut u8>();
                            let l7 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len8 = l7;
                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

                            _rt::string_lift(bytes8)
                          };
                          result9.push(e9);
                        }
                        _rt::cabi_dealloc(base9, len9 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                        let l10 = i32::from(*arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l12 = *arg0.add(8+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l13 = *arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let base20 = l12;
                        let len20 = l13;
                        let mut result20 = _rt::Vec::with_capacity(len20);
                        for i in 0..len20 {
                          let base = base20.add(i * (4*::core::mem::size_of::<*const u8>()));
                          let e20 = {
                            let l14 = *base.add(0).cast::<*mut u8>();
                            let l15 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len16 = l15;
                            let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);
                            let l17 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l18 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len19 = l18;
                            let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                            (_rt::string_lift(bytes16), _rt::string_lift(bytes19))
                          };
                          result20.push(e20);
                        }
                        _rt::cabi_dealloc(base20, len20 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                        let l21 = i32::from(*arg0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        T::run_streaming(l0 as u32, _rt::string_lift(bytes3), result9, match l10 {
                          0 => None,
                          1 => {
                            let e = {
                              let l11 = *arg0.add(4+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                              wit_bindgen::rt::async_support::StreamReader::new(l11 as u32, &super::super::super::super::wit_stream::vtable0::VTABLE)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }, result20, match l21 {
                          0 => None,
                          1 => {
                            let e = {
                              let l22 = i32::from(*arg0.add(24+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l24 = i32::from(*arg0.add(40+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l26 = i32::from(*arg0.add(56+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l28 = i32::from(*arg0.add(72+6*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              super::super::super::super::exports::golem::exec::types::Limits{
                                time_ms: match l22 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l23 = *arg0.add(32+6*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l23 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                memory_bytes: match l24 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l25 = *arg0.add(48+6*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l25 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                file_size_bytes: match l26 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l27 = *arg0.add(64+6*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l27 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                max_processes: match l28 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l29 = *arg0.add(76+6*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                      l29 as u32
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        })
                      };
                      _rt::cabi_dealloc(arg0, 80+6*::core::mem::size_of::<*const u8>(), 8);
                      (result30).take_handle() as i32
                    } }
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_download_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                    _rt::run_ctors_once();let result1 = {
                      let len0 = arg2;
                      let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                      T::download(arg0 as u32, _rt::string_lift(bytes0))
                    };
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                      Ok(e) => { {
                        *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        let vec3 = (e).into_boxed_slice();
                        let ptr3 = vec3.as_ptr().cast::<u8>();
                        let len3 = vec3.len();
                        ::core::mem::forget(vec3);
                        *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                      } },
                      Err(e) => { {
                        *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                        use super::super::super::super::exports::golem::exec::types::Error as V13;
                        match e {
                          V13::UnsupportedLanguage=> {
                            {
                              *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          }
                          V13::CompilationFailed(e) => {
                            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout4, stderr:stderr4, exit_code:exit_code4, signal:signal4, } = e;
                            let vec5 = (stdout4.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                            *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = (stderr4.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                            *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                            match exit_code4 {
                              Some(e) => {
                                *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                              },
                              None => {
                                {
                                  *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };match signal4 {
                              Some(e) => {
                                *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let vec7 = (e.into_bytes()).into_boxed_slice();
                                let ptr7 = vec7.as_ptr().cast::<u8>();
                                let len7 = vec7.len();
                                ::core::mem::forget(vec7);
                                *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                                *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                              },
                              None => {
                                {
                                  *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };},
                            V13::RuntimeFailed(e) => {
                              *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                              let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout8, stderr:stderr8, exit_code:exit_code8, signal:signal8, } = e;
                              let vec9 = (stdout8.into_bytes()).into_boxed_slice();
                              let ptr9 = vec9.as_ptr().cast::<u8>();
                              let len9 = vec9.len();
                              ::core::mem::forget(vec9);
                              *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                              *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                              let vec10 = (stderr8.into_bytes()).into_boxed_slice();
                              let ptr10 = vec10.as_ptr().cast::<u8>();
                              let len10 = vec10.len();
                              ::core::mem::forget(vec10);
                              *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                              *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                              match exit_code8 {
                                Some(e) => {
                                  *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                },
                                None => {
                                  {
                                    *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };match signal8 {
                                Some(e) => {
                                  *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  let vec11 = (e.into_bytes()).into_boxed_slice();
                                  let ptr11 = vec11.as_ptr().cast::<u8>();
                                  let len11 = vec11.len();
                                  ::core::mem::forget(vec11);
                                  *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                                  *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                                },
                                None => {
                                  {
                                    *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };},
                              V13::Timeout=> {
                                {
                                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                                }
                              }
                              V13::ResourceExceeded=> {
                                {
                                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                                }
                              }
                              V13::Internal(e) => {
                                *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                                let vec12 = (e.into_bytes()).into_boxed_slice();
                                let ptr12 = vec12.as_ptr().cast::<u8>();
                                let len12 = vec12.len();
                                ::core::mem::forget(vec12);
                                *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                                *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                              },
                            }
                          } },
                        };ptr2
                      } }
                      #[doc(hidden)]
                      #[allow(non_snake_case)]
                      pub unsafe fn __post_return_download<T: Guest>(arg0: *mut u8,) { unsafe {
                        let l0 = i32::from(*arg0.add(0).cast::<u8>());
                        match l0 {
                          0 => {
                            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                          },
                          _ => {
                            let l4 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                            match l4 {
                              0 => (),
                              1 => {
                                let l5 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l6 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l5, l6, 1);
                                let l7 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l8 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l7, l8, 1);
                                let l9 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l9 {
                                  0 => (),
                                  _ => {
                                    let l10 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l11 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                  },
                                }
                              },
                              2 => {
                                let l12 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l13 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l12, l13, 1);
                                let l14 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l15 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l14, l15, 1);
                                let l16 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l16 {
                                  0 => (),
                                  _ => {
                                    let l17 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l18 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                  },
                                }
                              },
                              3 => (),
                              4 => (),
                              _ => {
                                let l19 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l20 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                _rt::cabi_dealloc(l19, l20, 1);
                              },
                            }
                          },
                        }
                      } }
                      #[doc(hidden)]
                      #[allow(non_snake_case, unused_unsafe)]
                      pub unsafe fn _export_list_files_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                      _rt::run_ctors_once();let result1 = {
                        let len0 = arg2;
                        let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                        T::list_files(arg0 as u32, _rt::string_lift(bytes0))
                      };
                      let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                      match result1 {
                        Ok(e) => { {
                          *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                          let vec4 = e;
                          let len4 = vec4.len();
                          let layout4 = _rt::alloc::Layout::from_size_align(vec4.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result4, _cleanup4) = wit_bindgen::rt::Cleanup::new(layout4);if let Some(cleanup) = _cleanup4 { cleanup.forget(); }
                          for (i, e) in vec4.into_iter().enumerate() {
                            let base = result4.add(i * (2*::core::mem::size_of::<*const u8>()));
                            {
                              let vec3 = (e.into_bytes()).into_boxed_slice();
                              let ptr3 = vec3.as_ptr().cast::<u8>();
                              let len3 = vec3.len();
                              ::core::mem::forget(vec3);
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                              *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            }
                          }
                          *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                          *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result4;
                        } },
                        Err(e) => { {
                          *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                          use super::super::super::super::exports::golem::exec::types::Error as V14;
                          match e {
                            V14::UnsupportedLanguage=> {
                              {
                                *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            }
                            V14::CompilationFailed(e) => {
                              *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout5, stderr:stderr5, exit_code:exit_code5, signal:signal5, } = e;
                              let vec6 = (stdout5.into_bytes()).into_boxed_slice();
                              let ptr6 = vec6.as_ptr().cast::<u8>();
                              let len6 = vec6.len();
                              ::core::mem::forget(vec6);
                              *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                              *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                              let vec7 = (stderr5.into_bytes()).into_boxed_slice();
                              let ptr7 = vec7.as_ptr().cast::<u8>();
                              let len7 = vec7.len();
                              ::core::mem::forget(vec7);
                              *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                              *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                              match exit_code5 {
                                Some(e) => {
                                  *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                },
                                None => {
                                  {
                                    *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };match signal5 {
                                Some(e) => {
                                  *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  let vec8 = (e.into_bytes()).into_boxed_slice();
                                  let ptr8 = vec8.as_ptr().cast::<u8>();
                                  let len8 = vec8.len();
                                  ::core::mem::forget(vec8);
                                  *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                                  *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                                },
                                None => {
                                  {
                                    *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };},
                              V14::RuntimeFailed(e) => {
                                *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                                let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout9, stderr:stderr9, exit_code:exit_code9, signal:signal9, } = e;
                                let vec10 = (stdout9.into_bytes()).into_boxed_slice();
                                let ptr10 = vec10.as_ptr().cast::<u8>();
                                let len10 = vec10.len();
                                ::core::mem::forget(vec10);
                                *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                                *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                                let vec11 = (stderr9.into_bytes()).into_boxed_slice();
                                let ptr11 = vec11.as_ptr().cast::<u8>();
                                let len11 = vec11.len();
                                ::core::mem::forget(vec11);
                                *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                                *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                                match exit_code9 {
                                  Some(e) => {
                                    *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                  },
                                  None => {
                                    {
                                      *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };match signal9 {
                                  Some(e) => {
                                    *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                                    *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                                  },
                                  None => {
                                    {
                                      *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };},
                                V14::Timeout=> {
                                  {
                                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                                  }
                                }
                                V14::ResourceExceeded=> {
                                  {
                                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                                  }
                                }
                                V14::Internal(e) => {
                                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                                  let vec13 = (e.into_bytes()).into_boxed_slice();
                                  let ptr13 = vec13.as_ptr().cast::<u8>();
                                  let len13 = vec13.len();
                                  ::core::mem::forget(vec13);
                                  *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                                  *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                                },
                              }
                            } },
                          };ptr2
                        } }
                        #[doc(hidden)]
                        #[allow(non_snake_case)]
                        pub unsafe fn __post_return_list_files<T: Guest>(arg0: *mut u8,) { unsafe {
                          let l0 = i32::from(*arg0.add(0).cast::<u8>());
                          match l0 {
                            0 => {
                              let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base5 = l1;
                              let len5 = l2;
                              for i in 0..len5 {
                                let base = base5.add(i * (2*::core::mem::size_of::<*const u8>()));
                                {
                                  let l3 = *base.add(0).cast::<*mut u8>();
                                  let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l3, l4, 1);
                                }
                              }
                              _rt::cabi_dealloc(base5, len5 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                            },
                            _ => {
                              let l6 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                              match l6 {
                                0 => (),
                                1 => {
                                  let l7 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l8 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l7, l8, 1);
                                  let l9 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l10 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l9, l10, 1);
                                  let l11 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  match l11 {
                                    0 => (),
                                    _ => {
                                      let l12 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l13 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      _rt::cabi_dealloc(l12, l13, 1);
                                    },
                                  }
                                },
                                2 => {
                                  let l14 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l15 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l14, l15, 1);
                                  let l16 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l17 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l16, l17, 1);
                                  let l18 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  match l18 {
                                    0 => (),
                                    _ => {
                                      let l19 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l20 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      _rt::cabi_dealloc(l19, l20, 1);
                                    },
                                  }
                                },
                                3 => (),
                                4 => (),
                                _ => {
                                  let l21 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l22 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  _rt::cabi_dealloc(l21, l22, 1);
                                },
                              }
                            },
                          }
                        } }
                        #[doc(hidden)]
                        #[allow(non_snake_case, unused_unsafe)]
                        pub unsafe fn _export_set_working_dir_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                        _rt::run_ctors_once();let result1 = {
                          let len0 = arg2;
                          let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                          T::set_working_dir(arg0 as u32, _rt::string_lift(bytes0))
                        };
                        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                        match result1 {
                          Ok(_) => { {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                          } },
                          Err(e) => { {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::exec::types::Error as V12;
                            match e {
                              V12::UnsupportedLanguage=> {
                                {
                                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              }
                              V12::CompilationFailed(e) => {
                                *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout3, stderr:stderr3, exit_code:exit_code3, signal:signal3, } = e;
                                let vec4 = (stdout3.into_bytes()).into_boxed_slice();
                                let ptr4 = vec4.as_ptr().cast::<u8>();
                                let len4 = vec4.len();
                                ::core::mem::forget(vec4);
                                *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                                *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                                let vec5 = (stderr3.into_bytes()).into_boxed_slice();
                                let ptr5 = vec5.as_ptr().cast::<u8>();
                                let len5 = vec5.len();
                                ::core::mem::forget(vec5);
                                *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                                *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                                match exit_code3 {
                                  Some(e) => {
                                    *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                  },
                                  None => {
                                    {
                                      *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };match signal3 {
                                  Some(e) => {
                                    *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                                    *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                                  },
                                  None => {
                                    {
                                      *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };},
                                V12::RuntimeFailed(e) => {
                                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                                  let super::super::super::super::exports::golem::exec::types::StageResult{ stdout:stdout7, stderr:stderr7, exit_code:exit_code7, signal:signal7, } = e;
                                  let vec8 = (stdout7.into_bytes()).into_boxed_slice();
                                  let ptr8 = vec8.as_ptr().cast::<u8>();
                                  let len8 = vec8.len();
                                  ::core::mem::forget(vec8);
                                  *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                                  *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                                  let vec9 = (stderr7.into_bytes()).into_boxed_slice();
                                  let ptr9 = vec9.as_ptr().cast::<u8>();
                                  let len9 = vec9.len();
                                  ::core::mem::forget(vec9);
                                  *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                                  *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                                  match exit_code7 {
                                    Some(e) => {
                                      *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                      *ptr2.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                    },
                                    None => {
                                      {
                                        *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };match signal7 {
                                    Some(e) => {
                                      *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                      let vec10 = (e.into_bytes()).into_boxed_slice();
                                      let ptr10 = vec10.as_ptr().cast::<u8>();
                                      let len10 = vec10.len();
                                      ::core::mem::forget(vec10);
                                      *ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                                      *ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                                    },
                                    None => {
                                      {
                                        *ptr2.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };},
                                  V12::Timeout=> {
                                    {
                                      *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                                    }
                                  }
                                  V12::ResourceExceeded=> {
                                    {
                                      *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                                    }
                                  }
                                  V12::Internal(e) => {
                                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                                    *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                                  },
                                }
                              } },
                            };ptr2
                          } }
                          #[doc(hidden)]
                          #[allow(non_snake_case)]
                          pub unsafe fn __post_return_set_working_dir<T: Guest>(arg0: *mut u8,) { unsafe {
                            let l0 = i32::from(*arg0.add(0).cast::<u8>());
                            match l0 {
                              0 => (),
                              _ => {
                                let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                match l1 {
                                  0 => (),
                                  1 => {
                                    let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                    let l4 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l5 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                    let l6 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                    match l6 {
                                      0 => (),
                                      _ => {
                                        let l7 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                        let l8 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                        _rt::cabi_dealloc(l7, l8, 1);
                                      },
                                    }
                                  },
                                  2 => {
                                    let l9 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l10 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                    let l11 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l12 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                    let l13 = i32::from(*arg0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                    match l13 {
                                      0 => (),
                                      _ => {
                                        let l14 = *arg0.add(8+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                        let l15 = *arg0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                        _rt::cabi_dealloc(l14, l15, 1);
                                      },
                                    }
                                  },
                                  3 => (),
                                  4 => (),
                                  _ => {
                                    let l16 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l17 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                  },
                                }
                              },
                            }
                          } }
                          #[doc(hidden)]
                          #[allow(non_snake_case, unused_unsafe)]
                          pub unsafe fn _export_close_cabi<T: Guest>(arg0: i32,) { unsafe {#[cfg(target_arch="wasm32")]
                          _rt::run_ctors_once();{
                            T::close(arg0 as u32)
                          };
                        } }
                        pub trait Guest {
                          /// Create a new session
                          #[allow(async_fn_in_trait)]
                          fn create(lang: Language,) -> Result<SessionHandle,Error>;
                          /// Upload file to session
                          #[allow(async_fn_in_trait)]
                          fn upload(session: SessionHandle,file: File,) -> Result<(),Error>;
                          /// Blocking execution
                          #[allow(async_fn_in_trait)]
                          fn run(session: SessionHandle,entrypoint: _rt::String,args: _rt::Vec::<_rt::String>,stdin: Option<_rt::String>,env: _rt::Vec::<(_rt::String,_rt::String,)>,constraints: Option<Limits>,) -> Result<ExecResult,Error>;
                          /// Streaming execution
                          #[allow(async_fn_in_trait)]
                          fn run_streaming(session: SessionHandle,entrypoint: _rt::String,args: _rt::Vec::<_rt::String>,stdin: Option<wit_bindgen::rt::async_support::StreamReader<_rt::Vec::<u8>>>,env: _rt::Vec::<(_rt::String,_rt::String,)>,constraints: Option<Limits>,) -> wit_bindgen::rt::async_support::StreamReader<ExecEvent>;
                          /// Download file from session
                          #[allow(async_fn_in_trait)]
                          fn download(session: SessionHandle,path: _rt::String,) -> Result<_rt::Vec::<u8>,Error>;
                          /// List files in session directory
                          #[allow(async_fn_in_trait)]
                          fn list_files(session: SessionHandle,dir: _rt::String,) -> Result<_rt::Vec::<_rt::String>,Error>;
                          /// Set working directory for session
                          #[allow(async_fn_in_trait)]
                          fn set_working_dir(session: SessionHandle,path: _rt::String,) -> Result<(),Error>;
                          /// Close and cleanup session
                          #[allow(async_fn_in_trait)]
                          fn close(session: SessionHandle,) -> ();
                        }
                        #[doc(hidden)]

                        macro_rules! __export_golem_exec_session_1_0_0_cabi{
                          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

                            #[unsafe(export_name = "golem:exec/session@1.0.0#create")]
                            unsafe extern "C" fn export_create(arg0: i32,arg1: i32,arg2: *mut u8,arg3: usize,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_create_cabi::<$ty>(arg0, arg1, arg2, arg3) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#create")]
                            unsafe extern "C" fn _post_return_create(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_create::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#upload")]
                            unsafe extern "C" fn export_upload(arg0: i32,arg1: *mut u8,arg2: usize,arg3: *mut u8,arg4: usize,arg5: i32,arg6: i32,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_upload_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#upload")]
                            unsafe extern "C" fn _post_return_upload(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_upload::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#run")]
                            unsafe extern "C" fn export_run(arg0: *mut u8,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_run_cabi::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#run")]
                            unsafe extern "C" fn _post_return_run(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_run::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#run-streaming")]
                            unsafe extern "C" fn export_run_streaming(arg0: *mut u8,) -> i32 {
                              unsafe { $($path_to_types)*::_export_run_streaming_cabi::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#download")]
                            unsafe extern "C" fn export_download(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_download_cabi::<$ty>(arg0, arg1, arg2) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#download")]
                            unsafe extern "C" fn _post_return_download(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_download::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#list-files")]
                            unsafe extern "C" fn export_list_files(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_list_files_cabi::<$ty>(arg0, arg1, arg2) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#list-files")]
                            unsafe extern "C" fn _post_return_list_files(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_list_files::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#set-working-dir")]
                            unsafe extern "C" fn export_set_working_dir(arg0: i32,arg1: *mut u8,arg2: usize,) -> *mut u8 {
                              unsafe { $($path_to_types)*::_export_set_working_dir_cabi::<$ty>(arg0, arg1, arg2) }
                            }
                            #[unsafe(export_name = "cabi_post_golem:exec/session@1.0.0#set-working-dir")]
                            unsafe extern "C" fn _post_return_set_working_dir(arg0: *mut u8,) {
                              unsafe { $($path_to_types)*::__post_return_set_working_dir::<$ty>(arg0) }
                            }
                            #[unsafe(export_name = "golem:exec/session@1.0.0#close")]
                            unsafe extern "C" fn export_close(arg0: i32,) {
                              unsafe { $($path_to_types)*::_export_close_cabi::<$ty>(arg0) }
                            }
                          };);
                        }
                        #[doc(hidden)]
                        pub(crate) use __export_golem_exec_session_1_0_0_cabi;

                        #[repr(align(8))]
                        struct _RetArea([::core::mem::MaybeUninit::<u8>; 64+14*::core::mem::size_of::<*const u8>()]);
                        static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 64+14*::core::mem::size_of::<*const u8>()]);

                      }

                    }
                  }
                }
                mod _rt {
                  #![allow(dead_code, clippy::all)]
                  pub use alloc_crate::string::String;
                  pub use alloc_crate::vec::Vec;

                  #[cfg(target_arch = "wasm32")]
                  pub fn run_ctors_once() {
                    wit_bindgen::rt::run_ctors_once();
                  }
                  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
                    if cfg!(debug_assertions) {
                      String::from_utf8(bytes).unwrap()
                    } else {
                      unsafe { String::from_utf8_unchecked(bytes) }
                    }
                  }
                  pub unsafe fn invalid_enum_discriminant<T>() -> T {
                    if cfg!(debug_assertions) {
                      panic!("invalid enum discriminant")
                    } else {
                      unsafe { core::hint::unreachable_unchecked() }
                    }
                  }
                  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
                    if size == 0 {
                      return;
                    }
                    unsafe {
                      let layout = alloc::Layout::from_size_align_unchecked(size, align);
                      alloc::dealloc(ptr, layout);
                    }
                  }
                  
                  pub fn as_i32<T: AsI32>(t: T) -> i32 {
                    t.as_i32()
                  }

                  pub trait AsI32 {
                    fn as_i32(self) -> i32;
                  }

                  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
                    fn as_i32(self) -> i32 {
                      (*self).as_i32()
                    }
                  }
                  
                  impl AsI32 for i32 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for u32 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for i16 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for u16 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for i8 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for u8 {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for char {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  impl AsI32 for usize {
                    #[inline]
                    fn as_i32(self) -> i32 {
                      self as i32
                    }
                  }
                  
                  pub fn as_i64<T: AsI64>(t: T) -> i64 {
                    t.as_i64()
                  }

                  pub trait AsI64 {
                    fn as_i64(self) -> i64;
                  }

                  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
                    fn as_i64(self) -> i64 {
                      (*self).as_i64()
                    }
                  }
                  
                  impl AsI64 for i64 {
                    #[inline]
                    fn as_i64(self) -> i64 {
                      self as i64
                    }
                  }
                  
                  impl AsI64 for u64 {
                    #[inline]
                    fn as_i64(self) -> i64 {
                      self as i64
                    }
                  }
                  pub use alloc_crate::alloc;
                  extern crate alloc as alloc_crate;
                }
                pub mod wit_stream {
                  #![allow(dead_code, unused_variables, clippy::all)]

                  pub trait StreamPayload: Unpin + Sized + 'static {
                    const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
                  }
                  #[doc(hidden)]
                  #[allow(unused_unsafe)]
                  pub mod vtable0 {

                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn close_writable(_: u32) { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn close_readable(_: u32) { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn new() -> u64 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "[export]golem:exec/executor@1.0.0")]
                    unsafe extern "C" {
                      #[link_name = "[stream-new-0]run-streaming"]
                      fn new() -> u64;
                      #[link_name = "[stream-cancel-write-0]run-streaming"]
                      fn cancel_write(_: u32) -> u32;
                      #[link_name = "[stream-cancel-read-0]run-streaming"]
                      fn cancel_read(_: u32) -> u32;
                      #[link_name = "[stream-close-writable-0]run-streaming"]
                      fn close_writable(_: u32);
                      #[link_name = "[stream-close-readable-0]run-streaming"]
                      fn close_readable(_: u32);
                      #[link_name = "[async-lower][stream-read-0]run-streaming"]
                      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
                      #[link_name = "[async-lower][stream-write-0]run-streaming"]
                      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
                    }

                    unsafe fn lift(ptr: *mut u8) -> super::super::_rt::Vec::<u8> { unsafe { let l0 = *ptr.add(0).cast::<*mut u8>();
                    let l1 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len2 = l1;

                    super::super::_rt::Vec::from_raw_parts(l0.cast(), len2, len2) } }
                    unsafe fn lower(value: super::super::_rt::Vec::<u8>, ptr: *mut u8) { unsafe { let vec0 = (value).into_boxed_slice();
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    ::core::mem::forget(vec0);
                    *ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
                    *ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                  } }
                  unsafe fn dealloc_lists(ptr: *mut u8) { unsafe { let l0 = *ptr.add(0).cast::<*mut u8>();
                  let l1 = *ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base2 = l0;
                  let len2 = l1;
                  super::super::_rt::cabi_dealloc(base2, len2 * 1, 1);
                } }

                pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::_rt::Vec::<u8>> = wit_bindgen::rt::async_support::StreamVtable::<super::super::_rt::Vec::<u8>> {
                  cancel_write,
                  cancel_read,
                  close_writable,
                  close_readable,
                  dealloc_lists: Some(dealloc_lists),
                  layout: unsafe {
                    ::std::alloc::Layout::from_size_align_unchecked(8, 4)
                  },
                  lift: Some(lift),
                  lower: Some(lower),
                  new,
                  start_read,
                  start_write,
                };

                impl super::StreamPayload for super::super::_rt::Vec::<u8> {
                  const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
                }
              }
              
              #[doc(hidden)]
              #[allow(unused_unsafe)]
              pub mod vtable1 {

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn close_writable(_: u32) { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn close_readable(_: u32) { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn new() -> u64 { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "[export]golem:exec/executor@1.0.0")]
                unsafe extern "C" {
                  #[link_name = "[stream-new-1]run-streaming"]
                  fn new() -> u64;
                  #[link_name = "[stream-cancel-write-1]run-streaming"]
                  fn cancel_write(_: u32) -> u32;
                  #[link_name = "[stream-cancel-read-1]run-streaming"]
                  fn cancel_read(_: u32) -> u32;
                  #[link_name = "[stream-close-writable-1]run-streaming"]
                  fn close_writable(_: u32);
                  #[link_name = "[stream-close-readable-1]run-streaming"]
                  fn close_readable(_: u32);
                  #[link_name = "[async-lower][stream-read-1]run-streaming"]
                  fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
                  #[link_name = "[async-lower][stream-write-1]run-streaming"]
                  fn start_write(_: u32, _: *const u8, _: usize) -> u32;
                }

                unsafe fn lift(ptr: *mut u8) -> super::super::exports::golem::exec::executor::ExecEvent { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
                use super::super::exports::golem::exec::types::ExecEvent as V65;
                let v65 = match l0 {
                  0 => {
                    let e65 = {
                      let l1 = *ptr.add(8).cast::<*mut u8>();
                      let l2 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len3 = l2;

                      super::super::_rt::Vec::from_raw_parts(l1.cast(), len3, len3)
                    };
                    V65::StdoutChunk(e65)
                  }
                  1 => {
                    let e65 = {
                      let l4 = *ptr.add(8).cast::<*mut u8>();
                      let l5 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len6 = l5;

                      super::super::_rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                    };
                    V65::StderrChunk(e65)
                  }
                  2 => {
                    let e65 = {
                      let l7 = i32::from(*ptr.add(8).cast::<u8>());
                      let l20 = *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l21 = *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len22 = l21;
                      let bytes22 = super::super::_rt::Vec::from_raw_parts(l20.cast(), len22, len22);
                      let l23 = *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l24 = *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len25 = l24;
                      let bytes25 = super::super::_rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                      let l26 = i32::from(*ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l28 = i32::from(*ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l32 = i32::from(*ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l34 = i32::from(*ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::exports::golem::exec::types::ExecResult{
                        compile: match l7 {
                          0 => None,
                          1 => {
                            let e = {
                              let l8 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l9 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len10 = l9;
                              let bytes10 = super::super::_rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                              let l11 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l12 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len13 = l12;
                              let bytes13 = super::super::_rt::Vec::from_raw_parts(l11.cast(), len13, len13);
                              let l14 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l16 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              super::super::exports::golem::exec::types::StageResult{
                                stdout: super::super::_rt::string_lift(bytes10),
                                stderr: super::super::_rt::string_lift(bytes13),
                                exit_code: match l14 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l15 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                      l15
                                    };
                                    Some(e)
                                  }
                                  _ => super::super::_rt::invalid_enum_discriminant(),
                                },
                                signal: match l16 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l17 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l18 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let len19 = l18;
                                      let bytes19 = super::super::_rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                                      super::super::_rt::string_lift(bytes19)
                                    };
                                    Some(e)
                                  }
                                  _ => super::super::_rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => super::super::_rt::invalid_enum_discriminant(),
                        },
                        run: super::super::exports::golem::exec::types::StageResult{
                          stdout: super::super::_rt::string_lift(bytes22),
                          stderr: super::super::_rt::string_lift(bytes25),
                          exit_code: match l26 {
                            0 => None,
                            1 => {
                              let e = {
                                let l27 = *ptr.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                l27
                              };
                              Some(e)
                            }
                            _ => super::super::_rt::invalid_enum_discriminant(),
                          },
                          signal: match l28 {
                            0 => None,
                            1 => {
                              let e = {
                                let l29 = *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l30 = *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len31 = l30;
                                let bytes31 = super::super::_rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                                super::super::_rt::string_lift(bytes31)
                              };
                              Some(e)
                            }
                            _ => super::super::_rt::invalid_enum_discriminant(),
                          },
                        },
                        time_ms: match l32 {
                          0 => None,
                          1 => {
                            let e = {
                              let l33 = *ptr.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>();

                              l33 as u64
                            };
                            Some(e)
                          }
                          _ => super::super::_rt::invalid_enum_discriminant(),
                        },
                        memory_bytes: match l34 {
                          0 => None,
                          1 => {
                            let e = {
                              let l35 = *ptr.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>();

                              l35 as u64
                            };
                            Some(e)
                          }
                          _ => super::super::_rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V65::Finished(e65)
                  }
                  n => {
                    debug_assert_eq!(n, 3, "invalid enum discriminant");
                    let e65 = {
                      let l36 = i32::from(*ptr.add(8).cast::<u8>());
                      use super::super::exports::golem::exec::types::Error as V64;
                      let v64 = match l36 {
                        0 => {
                          V64::UnsupportedLanguage
                        }
                        1 => {
                          let e64 = {
                            let l37 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l38 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len39 = l38;
                            let bytes39 = super::super::_rt::Vec::from_raw_parts(l37.cast(), len39, len39);
                            let l40 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l41 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len42 = l41;
                            let bytes42 = super::super::_rt::Vec::from_raw_parts(l40.cast(), len42, len42);
                            let l43 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            let l45 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                            super::super::exports::golem::exec::types::StageResult{
                              stdout: super::super::_rt::string_lift(bytes39),
                              stderr: super::super::_rt::string_lift(bytes42),
                              exit_code: match l43 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l44 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                    l44
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                              signal: match l45 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l46 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l47 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len48 = l47;
                                    let bytes48 = super::super::_rt::Vec::from_raw_parts(l46.cast(), len48, len48);

                                    super::super::_rt::string_lift(bytes48)
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                            }
                          };
                          V64::CompilationFailed(e64)
                        }
                        2 => {
                          let e64 = {
                            let l49 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l50 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len51 = l50;
                            let bytes51 = super::super::_rt::Vec::from_raw_parts(l49.cast(), len51, len51);
                            let l52 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l53 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len54 = l53;
                            let bytes54 = super::super::_rt::Vec::from_raw_parts(l52.cast(), len54, len54);
                            let l55 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            let l57 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                            super::super::exports::golem::exec::types::StageResult{
                              stdout: super::super::_rt::string_lift(bytes51),
                              stderr: super::super::_rt::string_lift(bytes54),
                              exit_code: match l55 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l56 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                    l56
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                              signal: match l57 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l58 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l59 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len60 = l59;
                                    let bytes60 = super::super::_rt::Vec::from_raw_parts(l58.cast(), len60, len60);

                                    super::super::_rt::string_lift(bytes60)
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                            }
                          };
                          V64::RuntimeFailed(e64)
                        }
                        3 => {
                          V64::Timeout
                        }
                        4 => {
                          V64::ResourceExceeded
                        }
                        n => {
                          debug_assert_eq!(n, 5, "invalid enum discriminant");
                          let e64 = {
                            let l61 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l62 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len63 = l62;
                            let bytes63 = super::super::_rt::Vec::from_raw_parts(l61.cast(), len63, len63);

                            super::super::_rt::string_lift(bytes63)
                          };
                          V64::Internal(e64)
                        }
                      };

                      v64
                    };
                    V65::Failed(e65)
                  }
                };

                v65 } }
                unsafe fn lower(value: super::super::exports::golem::exec::executor::ExecEvent, ptr: *mut u8) { unsafe { use super::super::exports::golem::exec::types::ExecEvent as V21;
                match value {
                  V21::StdoutChunk(e) => {
                    *ptr.add(0).cast::<u8>() = (0i32) as u8;
                    let vec0 = (e).into_boxed_slice();
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    ::core::mem::forget(vec0);
                    *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
                    *ptr.add(8).cast::<*mut u8>() = ptr0.cast_mut();
                  },
                  V21::StderrChunk(e) => {
                    *ptr.add(0).cast::<u8>() = (1i32) as u8;
                    let vec1 = (e).into_boxed_slice();
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    ::core::mem::forget(vec1);
                    *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                    *ptr.add(8).cast::<*mut u8>() = ptr1.cast_mut();
                  },
                  V21::Finished(e) => {
                    *ptr.add(0).cast::<u8>() = (2i32) as u8;
                    let super::super::exports::golem::exec::types::ExecResult{ compile:compile2, run:run2, time_ms:time_ms2, memory_bytes:memory_bytes2, } = e;
                    match compile2 {
                      Some(e) => {
                        *ptr.add(8).cast::<u8>() = (1i32) as u8;
                        let super::super::exports::golem::exec::types::StageResult{ stdout:stdout3, stderr:stderr3, exit_code:exit_code3, signal:signal3, } = e;
                        let vec4 = (stdout3.into_bytes()).into_boxed_slice();
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        ::core::mem::forget(vec4);
                        *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                        *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                        let vec5 = (stderr3.into_bytes()).into_boxed_slice();
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        ::core::mem::forget(vec5);
                        *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                        *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                        match exit_code3 {
                          Some(e) => {
                            *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                          },
                          None => {
                            {
                              *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match signal3 {
                          Some(e) => {
                            *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                            *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                          },
                          None => {
                            {
                              *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        None => {
                          {
                            *ptr.add(8).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let super::super::exports::golem::exec::types::StageResult{ stdout:stdout7, stderr:stderr7, exit_code:exit_code7, signal:signal7, } = run2;
                      let vec8 = (stdout7.into_bytes()).into_boxed_slice();
                      let ptr8 = vec8.as_ptr().cast::<u8>();
                      let len8 = vec8.len();
                      ::core::mem::forget(vec8);
                      *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                      *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                      let vec9 = (stderr7.into_bytes()).into_boxed_slice();
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      ::core::mem::forget(vec9);
                      *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                      *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                      match exit_code7 {
                        Some(e) => {
                          *ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                        },
                        None => {
                          {
                            *ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match signal7 {
                        Some(e) => {
                          *ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec10 = (e.into_bytes()).into_boxed_slice();
                          let ptr10 = vec10.as_ptr().cast::<u8>();
                          let len10 = vec10.len();
                          ::core::mem::forget(vec10);
                          *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                          *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                        },
                        None => {
                          {
                            *ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match time_ms2 {
                        Some(e) => {
                          *ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = super::super::_rt::as_i64(e);
                        },
                        None => {
                          {
                            *ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match memory_bytes2 {
                        Some(e) => {
                          *ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = super::super::_rt::as_i64(e);
                        },
                        None => {
                          {
                            *ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      V21::Failed(e) => {
                        *ptr.add(0).cast::<u8>() = (3i32) as u8;
                        use super::super::exports::golem::exec::types::Error as V20;
                        match e {
                          V20::UnsupportedLanguage=> {
                            {
                              *ptr.add(8).cast::<u8>() = (0i32) as u8;
                            }
                          }
                          V20::CompilationFailed(e) => {
                            *ptr.add(8).cast::<u8>() = (1i32) as u8;
                            let super::super::exports::golem::exec::types::StageResult{ stdout:stdout11, stderr:stderr11, exit_code:exit_code11, signal:signal11, } = e;
                            let vec12 = (stdout11.into_bytes()).into_boxed_slice();
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            ::core::mem::forget(vec12);
                            *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                            *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                            let vec13 = (stderr11.into_bytes()).into_boxed_slice();
                            let ptr13 = vec13.as_ptr().cast::<u8>();
                            let len13 = vec13.len();
                            ::core::mem::forget(vec13);
                            *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                            *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                            match exit_code11 {
                              Some(e) => {
                                *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                              },
                              None => {
                                {
                                  *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };match signal11 {
                              Some(e) => {
                                *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let vec14 = (e.into_bytes()).into_boxed_slice();
                                let ptr14 = vec14.as_ptr().cast::<u8>();
                                let len14 = vec14.len();
                                ::core::mem::forget(vec14);
                                *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                                *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14.cast_mut();
                              },
                              None => {
                                {
                                  *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };},
                            V20::RuntimeFailed(e) => {
                              *ptr.add(8).cast::<u8>() = (2i32) as u8;
                              let super::super::exports::golem::exec::types::StageResult{ stdout:stdout15, stderr:stderr15, exit_code:exit_code15, signal:signal15, } = e;
                              let vec16 = (stdout15.into_bytes()).into_boxed_slice();
                              let ptr16 = vec16.as_ptr().cast::<u8>();
                              let len16 = vec16.len();
                              ::core::mem::forget(vec16);
                              *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                              *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr16.cast_mut();
                              let vec17 = (stderr15.into_bytes()).into_boxed_slice();
                              let ptr17 = vec17.as_ptr().cast::<u8>();
                              let len17 = vec17.len();
                              ::core::mem::forget(vec17);
                              *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
                              *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr17.cast_mut();
                              match exit_code15 {
                                Some(e) => {
                                  *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                                },
                                None => {
                                  {
                                    *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };match signal15 {
                                Some(e) => {
                                  *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  let vec18 = (e.into_bytes()).into_boxed_slice();
                                  let ptr18 = vec18.as_ptr().cast::<u8>();
                                  let len18 = vec18.len();
                                  ::core::mem::forget(vec18);
                                  *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                                  *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr18.cast_mut();
                                },
                                None => {
                                  {
                                    *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                  }
                                },
                              };},
                              V20::Timeout=> {
                                {
                                  *ptr.add(8).cast::<u8>() = (3i32) as u8;
                                }
                              }
                              V20::ResourceExceeded=> {
                                {
                                  *ptr.add(8).cast::<u8>() = (4i32) as u8;
                                }
                              }
                              V20::Internal(e) => {
                                *ptr.add(8).cast::<u8>() = (5i32) as u8;
                                let vec19 = (e.into_bytes()).into_boxed_slice();
                                let ptr19 = vec19.as_ptr().cast::<u8>();
                                let len19 = vec19.len();
                                ::core::mem::forget(vec19);
                                *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                                *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                              },
                            }
                          },
                        }
                      } }
                      unsafe fn dealloc_lists(ptr: *mut u8) { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
                      match l0 {
                        0 => {
                          let l1 = *ptr.add(8).cast::<*mut u8>();
                          let l2 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let base3 = l1;
                          let len3 = l2;
                          super::super::_rt::cabi_dealloc(base3, len3 * 1, 1);
                        },
                        1 => {
                          let l4 = *ptr.add(8).cast::<*mut u8>();
                          let l5 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let base6 = l4;
                          let len6 = l5;
                          super::super::_rt::cabi_dealloc(base6, len6 * 1, 1);
                        },
                        2 => {
                          let l7 = i32::from(*ptr.add(8).cast::<u8>());
                          match l7 {
                            0 => (),
                            _ => {
                              let l8 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l9 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l8, l9, 1);
                              let l10 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l11 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l10, l11, 1);
                              let l12 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              match l12 {
                                0 => (),
                                _ => {
                                  let l13 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l14 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l13, l14, 1);
                                },
                              }
                            },
                          }
                          let l15 = *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l16 = *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          super::super::_rt::cabi_dealloc(l15, l16, 1);
                          let l17 = *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l18 = *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          super::super::_rt::cabi_dealloc(l17, l18, 1);
                          let l19 = i32::from(*ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          match l19 {
                            0 => (),
                            _ => {
                              let l20 = *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l21 = *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l20, l21, 1);
                            },
                          }
                        },
                        _ => {
                          let l22 = i32::from(*ptr.add(8).cast::<u8>());
                          match l22 {
                            0 => (),
                            1 => {
                              let l23 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l24 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l23, l24, 1);
                              let l25 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l26 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l25, l26, 1);
                              let l27 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              match l27 {
                                0 => (),
                                _ => {
                                  let l28 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l29 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l28, l29, 1);
                                },
                              }
                            },
                            2 => {
                              let l30 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l31 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l30, l31, 1);
                              let l32 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l33 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l32, l33, 1);
                              let l34 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              match l34 {
                                0 => (),
                                _ => {
                                  let l35 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l36 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l35, l36, 1);
                                },
                              }
                            },
                            3 => (),
                            4 => (),
                            _ => {
                              let l37 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l38 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l37, l38, 1);
                            },
                          }
                        },
                      }
                    } }

                    pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::exports::golem::exec::executor::ExecEvent> = wit_bindgen::rt::async_support::StreamVtable::<super::super::exports::golem::exec::executor::ExecEvent> {
                      cancel_write,
                      cancel_read,
                      close_writable,
                      close_readable,
                      dealloc_lists: Some(dealloc_lists),
                      layout: unsafe {
                        ::std::alloc::Layout::from_size_align_unchecked(120, 8)
                      },
                      lift: Some(lift),
                      lower: Some(lower),
                      new,
                      start_read,
                      start_write,
                    };

                    impl super::StreamPayload for super::super::exports::golem::exec::executor::ExecEvent {
                      const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
                    }
                  }
                  
                  #[doc(hidden)]
                  #[allow(unused_unsafe)]
                  pub mod vtable2 {

                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn close_writable(_: u32) { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn close_readable(_: u32) { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn new() -> u64 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "[export]golem:exec/session@1.0.0")]
                    unsafe extern "C" {
                      #[link_name = "[stream-new-1]run-streaming"]
                      fn new() -> u64;
                      #[link_name = "[stream-cancel-write-1]run-streaming"]
                      fn cancel_write(_: u32) -> u32;
                      #[link_name = "[stream-cancel-read-1]run-streaming"]
                      fn cancel_read(_: u32) -> u32;
                      #[link_name = "[stream-close-writable-1]run-streaming"]
                      fn close_writable(_: u32);
                      #[link_name = "[stream-close-readable-1]run-streaming"]
                      fn close_readable(_: u32);
                      #[link_name = "[async-lower][stream-read-1]run-streaming"]
                      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
                      #[link_name = "[async-lower][stream-write-1]run-streaming"]
                      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
                    }

                    unsafe fn lift(ptr: *mut u8) -> super::super::exports::golem::exec::session::ExecEvent { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
                    use super::super::exports::golem::exec::types::ExecEvent as V65;
                    let v65 = match l0 {
                      0 => {
                        let e65 = {
                          let l1 = *ptr.add(8).cast::<*mut u8>();
                          let l2 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len3 = l2;

                          super::super::_rt::Vec::from_raw_parts(l1.cast(), len3, len3)
                        };
                        V65::StdoutChunk(e65)
                      }
                      1 => {
                        let e65 = {
                          let l4 = *ptr.add(8).cast::<*mut u8>();
                          let l5 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len6 = l5;

                          super::super::_rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                        };
                        V65::StderrChunk(e65)
                      }
                      2 => {
                        let e65 = {
                          let l7 = i32::from(*ptr.add(8).cast::<u8>());
                          let l20 = *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l21 = *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len22 = l21;
                          let bytes22 = super::super::_rt::Vec::from_raw_parts(l20.cast(), len22, len22);
                          let l23 = *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l24 = *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len25 = l24;
                          let bytes25 = super::super::_rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                          let l26 = i32::from(*ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l28 = i32::from(*ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l32 = i32::from(*ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                          let l34 = i32::from(*ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>());

                          super::super::exports::golem::exec::types::ExecResult{
                            compile: match l7 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l8 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l9 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len10 = l9;
                                  let bytes10 = super::super::_rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                                  let l11 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l12 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len13 = l12;
                                  let bytes13 = super::super::_rt::Vec::from_raw_parts(l11.cast(), len13, len13);
                                  let l14 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  let l16 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                  super::super::exports::golem::exec::types::StageResult{
                                    stdout: super::super::_rt::string_lift(bytes10),
                                    stderr: super::super::_rt::string_lift(bytes13),
                                    exit_code: match l14 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l15 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                          l15
                                        };
                                        Some(e)
                                      }
                                      _ => super::super::_rt::invalid_enum_discriminant(),
                                    },
                                    signal: match l16 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l17 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                          let l18 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len19 = l18;
                                          let bytes19 = super::super::_rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                                          super::super::_rt::string_lift(bytes19)
                                        };
                                        Some(e)
                                      }
                                      _ => super::super::_rt::invalid_enum_discriminant(),
                                    },
                                  }
                                };
                                Some(e)
                              }
                              _ => super::super::_rt::invalid_enum_discriminant(),
                            },
                            run: super::super::exports::golem::exec::types::StageResult{
                              stdout: super::super::_rt::string_lift(bytes22),
                              stderr: super::super::_rt::string_lift(bytes25),
                              exit_code: match l26 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l27 = *ptr.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                    l27
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                              signal: match l28 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l29 = *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l30 = *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len31 = l30;
                                    let bytes31 = super::super::_rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                                    super::super::_rt::string_lift(bytes31)
                                  };
                                  Some(e)
                                }
                                _ => super::super::_rt::invalid_enum_discriminant(),
                              },
                            },
                            time_ms: match l32 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l33 = *ptr.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                  l33 as u64
                                };
                                Some(e)
                              }
                              _ => super::super::_rt::invalid_enum_discriminant(),
                            },
                            memory_bytes: match l34 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l35 = *ptr.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                  l35 as u64
                                };
                                Some(e)
                              }
                              _ => super::super::_rt::invalid_enum_discriminant(),
                            },
                          }
                        };
                        V65::Finished(e65)
                      }
                      n => {
                        debug_assert_eq!(n, 3, "invalid enum discriminant");
                        let e65 = {
                          let l36 = i32::from(*ptr.add(8).cast::<u8>());
                          use super::super::exports::golem::exec::types::Error as V64;
                          let v64 = match l36 {
                            0 => {
                              V64::UnsupportedLanguage
                            }
                            1 => {
                              let e64 = {
                                let l37 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l38 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len39 = l38;
                                let bytes39 = super::super::_rt::Vec::from_raw_parts(l37.cast(), len39, len39);
                                let l40 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l41 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len42 = l41;
                                let bytes42 = super::super::_rt::Vec::from_raw_parts(l40.cast(), len42, len42);
                                let l43 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                let l45 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                super::super::exports::golem::exec::types::StageResult{
                                  stdout: super::super::_rt::string_lift(bytes39),
                                  stderr: super::super::_rt::string_lift(bytes42),
                                  exit_code: match l43 {
                                    0 => None,
                                    1 => {
                                      let e = {
                                        let l44 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                        l44
                                      };
                                      Some(e)
                                    }
                                    _ => super::super::_rt::invalid_enum_discriminant(),
                                  },
                                  signal: match l45 {
                                    0 => None,
                                    1 => {
                                      let e = {
                                        let l46 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                        let l47 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                        let len48 = l47;
                                        let bytes48 = super::super::_rt::Vec::from_raw_parts(l46.cast(), len48, len48);

                                        super::super::_rt::string_lift(bytes48)
                                      };
                                      Some(e)
                                    }
                                    _ => super::super::_rt::invalid_enum_discriminant(),
                                  },
                                }
                              };
                              V64::CompilationFailed(e64)
                            }
                            2 => {
                              let e64 = {
                                let l49 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l50 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len51 = l50;
                                let bytes51 = super::super::_rt::Vec::from_raw_parts(l49.cast(), len51, len51);
                                let l52 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l53 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len54 = l53;
                                let bytes54 = super::super::_rt::Vec::from_raw_parts(l52.cast(), len54, len54);
                                let l55 = i32::from(*ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                let l57 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                super::super::exports::golem::exec::types::StageResult{
                                  stdout: super::super::_rt::string_lift(bytes51),
                                  stderr: super::super::_rt::string_lift(bytes54),
                                  exit_code: match l55 {
                                    0 => None,
                                    1 => {
                                      let e = {
                                        let l56 = *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                        l56
                                      };
                                      Some(e)
                                    }
                                    _ => super::super::_rt::invalid_enum_discriminant(),
                                  },
                                  signal: match l57 {
                                    0 => None,
                                    1 => {
                                      let e = {
                                        let l58 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                        let l59 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                        let len60 = l59;
                                        let bytes60 = super::super::_rt::Vec::from_raw_parts(l58.cast(), len60, len60);

                                        super::super::_rt::string_lift(bytes60)
                                      };
                                      Some(e)
                                    }
                                    _ => super::super::_rt::invalid_enum_discriminant(),
                                  },
                                }
                              };
                              V64::RuntimeFailed(e64)
                            }
                            3 => {
                              V64::Timeout
                            }
                            4 => {
                              V64::ResourceExceeded
                            }
                            n => {
                              debug_assert_eq!(n, 5, "invalid enum discriminant");
                              let e64 = {
                                let l61 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l62 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len63 = l62;
                                let bytes63 = super::super::_rt::Vec::from_raw_parts(l61.cast(), len63, len63);

                                super::super::_rt::string_lift(bytes63)
                              };
                              V64::Internal(e64)
                            }
                          };

                          v64
                        };
                        V65::Failed(e65)
                      }
                    };

                    v65 } }
                    unsafe fn lower(value: super::super::exports::golem::exec::session::ExecEvent, ptr: *mut u8) { unsafe { use super::super::exports::golem::exec::types::ExecEvent as V21;
                    match value {
                      V21::StdoutChunk(e) => {
                        *ptr.add(0).cast::<u8>() = (0i32) as u8;
                        let vec0 = (e).into_boxed_slice();
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        ::core::mem::forget(vec0);
                        *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
                        *ptr.add(8).cast::<*mut u8>() = ptr0.cast_mut();
                      },
                      V21::StderrChunk(e) => {
                        *ptr.add(0).cast::<u8>() = (1i32) as u8;
                        let vec1 = (e).into_boxed_slice();
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        ::core::mem::forget(vec1);
                        *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                        *ptr.add(8).cast::<*mut u8>() = ptr1.cast_mut();
                      },
                      V21::Finished(e) => {
                        *ptr.add(0).cast::<u8>() = (2i32) as u8;
                        let super::super::exports::golem::exec::types::ExecResult{ compile:compile2, run:run2, time_ms:time_ms2, memory_bytes:memory_bytes2, } = e;
                        match compile2 {
                          Some(e) => {
                            *ptr.add(8).cast::<u8>() = (1i32) as u8;
                            let super::super::exports::golem::exec::types::StageResult{ stdout:stdout3, stderr:stderr3, exit_code:exit_code3, signal:signal3, } = e;
                            let vec4 = (stdout3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                            *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = (stderr3.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                            *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                            match exit_code3 {
                              Some(e) => {
                                *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                              },
                              None => {
                                {
                                  *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };match signal3 {
                              Some(e) => {
                                *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                let vec6 = (e.into_bytes()).into_boxed_slice();
                                let ptr6 = vec6.as_ptr().cast::<u8>();
                                let len6 = vec6.len();
                                ::core::mem::forget(vec6);
                                *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                                *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                              },
                              None => {
                                {
                                  *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };},
                            None => {
                              {
                                *ptr.add(8).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };let super::super::exports::golem::exec::types::StageResult{ stdout:stdout7, stderr:stderr7, exit_code:exit_code7, signal:signal7, } = run2;
                          let vec8 = (stdout7.into_bytes()).into_boxed_slice();
                          let ptr8 = vec8.as_ptr().cast::<u8>();
                          let len8 = vec8.len();
                          ::core::mem::forget(vec8);
                          *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                          *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                          let vec9 = (stderr7.into_bytes()).into_boxed_slice();
                          let ptr9 = vec9.as_ptr().cast::<u8>();
                          let len9 = vec9.len();
                          ::core::mem::forget(vec9);
                          *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                          *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                          match exit_code7 {
                            Some(e) => {
                              *ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              *ptr.add(20+12*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                            },
                            None => {
                              {
                                *ptr.add(16+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match signal7 {
                            Some(e) => {
                              *ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec10 = (e.into_bytes()).into_boxed_slice();
                              let ptr10 = vec10.as_ptr().cast::<u8>();
                              let len10 = vec10.len();
                              ::core::mem::forget(vec10);
                              *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                              *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                            },
                            None => {
                              {
                                *ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match time_ms2 {
                            Some(e) => {
                              *ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              *ptr.add(40+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = super::super::_rt::as_i64(e);
                            },
                            None => {
                              {
                                *ptr.add(32+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match memory_bytes2 {
                            Some(e) => {
                              *ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              *ptr.add(56+14*::core::mem::size_of::<*const u8>()).cast::<i64>() = super::super::_rt::as_i64(e);
                            },
                            None => {
                              {
                                *ptr.add(48+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };},
                          V21::Failed(e) => {
                            *ptr.add(0).cast::<u8>() = (3i32) as u8;
                            use super::super::exports::golem::exec::types::Error as V20;
                            match e {
                              V20::UnsupportedLanguage=> {
                                {
                                  *ptr.add(8).cast::<u8>() = (0i32) as u8;
                                }
                              }
                              V20::CompilationFailed(e) => {
                                *ptr.add(8).cast::<u8>() = (1i32) as u8;
                                let super::super::exports::golem::exec::types::StageResult{ stdout:stdout11, stderr:stderr11, exit_code:exit_code11, signal:signal11, } = e;
                                let vec12 = (stdout11.into_bytes()).into_boxed_slice();
                                let ptr12 = vec12.as_ptr().cast::<u8>();
                                let len12 = vec12.len();
                                ::core::mem::forget(vec12);
                                *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                                *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                                let vec13 = (stderr11.into_bytes()).into_boxed_slice();
                                let ptr13 = vec13.as_ptr().cast::<u8>();
                                let len13 = vec13.len();
                                ::core::mem::forget(vec13);
                                *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                                *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                                match exit_code11 {
                                  Some(e) => {
                                    *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                                  },
                                  None => {
                                    {
                                      *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };match signal11 {
                                  Some(e) => {
                                    *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                                    *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14.cast_mut();
                                  },
                                  None => {
                                    {
                                      *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };},
                                V20::RuntimeFailed(e) => {
                                  *ptr.add(8).cast::<u8>() = (2i32) as u8;
                                  let super::super::exports::golem::exec::types::StageResult{ stdout:stdout15, stderr:stderr15, exit_code:exit_code15, signal:signal15, } = e;
                                  let vec16 = (stdout15.into_bytes()).into_boxed_slice();
                                  let ptr16 = vec16.as_ptr().cast::<u8>();
                                  let len16 = vec16.len();
                                  ::core::mem::forget(vec16);
                                  *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                                  *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr16.cast_mut();
                                  let vec17 = (stderr15.into_bytes()).into_boxed_slice();
                                  let ptr17 = vec17.as_ptr().cast::<u8>();
                                  let len17 = vec17.len();
                                  ::core::mem::forget(vec17);
                                  *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
                                  *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr17.cast_mut();
                                  match exit_code15 {
                                    Some(e) => {
                                      *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                      *ptr.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = super::super::_rt::as_i32(e);
                                    },
                                    None => {
                                      {
                                        *ptr.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };match signal15 {
                                    Some(e) => {
                                      *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                      let vec18 = (e.into_bytes()).into_boxed_slice();
                                      let ptr18 = vec18.as_ptr().cast::<u8>();
                                      let len18 = vec18.len();
                                      ::core::mem::forget(vec18);
                                      *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                                      *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr18.cast_mut();
                                    },
                                    None => {
                                      {
                                        *ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };},
                                  V20::Timeout=> {
                                    {
                                      *ptr.add(8).cast::<u8>() = (3i32) as u8;
                                    }
                                  }
                                  V20::ResourceExceeded=> {
                                    {
                                      *ptr.add(8).cast::<u8>() = (4i32) as u8;
                                    }
                                  }
                                  V20::Internal(e) => {
                                    *ptr.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                                    *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                                  },
                                }
                              },
                            }
                          } }
                          unsafe fn dealloc_lists(ptr: *mut u8) { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());
                          match l0 {
                            0 => {
                              let l1 = *ptr.add(8).cast::<*mut u8>();
                              let l2 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base3 = l1;
                              let len3 = l2;
                              super::super::_rt::cabi_dealloc(base3, len3 * 1, 1);
                            },
                            1 => {
                              let l4 = *ptr.add(8).cast::<*mut u8>();
                              let l5 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base6 = l4;
                              let len6 = l5;
                              super::super::_rt::cabi_dealloc(base6, len6 * 1, 1);
                            },
                            2 => {
                              let l7 = i32::from(*ptr.add(8).cast::<u8>());
                              match l7 {
                                0 => (),
                                _ => {
                                  let l8 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l9 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l8, l9, 1);
                                  let l10 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l11 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l10, l11, 1);
                                  let l12 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  match l12 {
                                    0 => (),
                                    _ => {
                                      let l13 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l14 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      super::super::_rt::cabi_dealloc(l13, l14, 1);
                                    },
                                  }
                                },
                              }
                              let l15 = *ptr.add(16+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l16 = *ptr.add(16+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l15, l16, 1);
                              let l17 = *ptr.add(16+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l18 = *ptr.add(16+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              super::super::_rt::cabi_dealloc(l17, l18, 1);
                              let l19 = i32::from(*ptr.add(24+12*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              match l19 {
                                0 => (),
                                _ => {
                                  let l20 = *ptr.add(24+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l21 = *ptr.add(24+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l20, l21, 1);
                                },
                              }
                            },
                            _ => {
                              let l22 = i32::from(*ptr.add(8).cast::<u8>());
                              match l22 {
                                0 => (),
                                1 => {
                                  let l23 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l24 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l23, l24, 1);
                                  let l25 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l26 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l25, l26, 1);
                                  let l27 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  match l27 {
                                    0 => (),
                                    _ => {
                                      let l28 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l29 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      super::super::_rt::cabi_dealloc(l28, l29, 1);
                                    },
                                  }
                                },
                                2 => {
                                  let l30 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l31 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l30, l31, 1);
                                  let l32 = *ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l33 = *ptr.add(8+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l32, l33, 1);
                                  let l34 = i32::from(*ptr.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  match l34 {
                                    0 => (),
                                    _ => {
                                      let l35 = *ptr.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l36 = *ptr.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      super::super::_rt::cabi_dealloc(l35, l36, 1);
                                    },
                                  }
                                },
                                3 => (),
                                4 => (),
                                _ => {
                                  let l37 = *ptr.add(8+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l38 = *ptr.add(8+2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  super::super::_rt::cabi_dealloc(l37, l38, 1);
                                },
                              }
                            },
                          }
                        } }

                        pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::exports::golem::exec::session::ExecEvent> = wit_bindgen::rt::async_support::StreamVtable::<super::super::exports::golem::exec::session::ExecEvent> {
                          cancel_write,
                          cancel_read,
                          close_writable,
                          close_readable,
                          dealloc_lists: Some(dealloc_lists),
                          layout: unsafe {
                            ::std::alloc::Layout::from_size_align_unchecked(120, 8)
                          },
                          lift: Some(lift),
                          lower: Some(lower),
                          new,
                          start_read,
                          start_write,
                        };

                        impl super::StreamPayload for super::super::exports::golem::exec::session::ExecEvent {
                          const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
                        }
                      }
                      /// Creates a new Component Model `stream` with the specified payload type.
                      pub fn new<T: StreamPayload>() -> (wit_bindgen::rt::async_support::StreamWriter<T>, wit_bindgen::rt::async_support::StreamReader<T>) {
                        unsafe { wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE) }
                      }
                    }
                    
                    /// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
                    /// the root implementation of all generated traits.
                    ///
                    /// For more information see the documentation of `wit_bindgen::generate!`.
                    ///
                    /// ```rust
                    /// # macro_rules! export{ ($($t:tt)*) => (); }
                    /// # trait Guest {}
                    /// struct MyType;
                    ///
                    /// impl Guest for MyType {
                    ///     // ...
                    /// }
                    ///
                    /// export!(MyType);
                    /// ```
                    #[allow(unused_macros)]
                    #[doc(hidden)]

                    macro_rules! __export_exec_library_impl {
                      ($ty:ident) => (self::export!($ty with_types_in self););
                      ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
                      $($path_to_types_root)*::exports::golem::exec::types::__export_golem_exec_types_1_0_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::golem::exec::types);
                      $($path_to_types_root)*::exports::golem::exec::executor::__export_golem_exec_executor_1_0_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::golem::exec::executor);
                      $($path_to_types_root)*::exports::golem::exec::session::__export_golem_exec_session_1_0_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::golem::exec::session);
                      )
                    }
                    #[doc(inline)]
                    pub(crate) use __export_exec_library_impl as export;

                    #[cfg(target_arch = "wasm32")]
                    #[unsafe(link_section = "component-type:wit-bindgen:0.42.1:golem:exec@1.0.0:exec-library:encoded world")]
                    #[doc(hidden)]
                    #[allow(clippy::octal_escapes)]
                    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1669] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x82\x0c\x01A\x02\x01\
A\x0c\x01B\x19\x01m\x02\x0ajavascript\x06python\x04\0\x0dlanguage-kind\x03\0\0\x01\
ks\x01r\x02\x04kind\x01\x07version\x02\x04\0\x08language\x03\0\x03\x01m\x03\x04u\
tf8\x06base64\x03hex\x04\0\x08encoding\x03\0\x05\x01p}\x01k\x06\x01r\x03\x04name\
s\x07content\x07\x08encoding\x08\x04\0\x04file\x03\0\x09\x01kw\x01ky\x01r\x04\x07\
time-ms\x0b\x0cmemory-bytes\x0b\x0ffile-size-bytes\x0b\x0dmax-processes\x0c\x04\0\
\x06limits\x03\0\x0d\x01kz\x01r\x04\x06stdouts\x06stderrs\x09exit-code\x0f\x06si\
gnal\x02\x04\0\x0cstage-result\x03\0\x10\x01k\x11\x01r\x04\x07compile\x12\x03run\
\x11\x07time-ms\x0b\x0cmemory-bytes\x0b\x04\0\x0bexec-result\x03\0\x13\x01q\x06\x14\
unsupported-language\0\0\x12compilation-failed\x01\x11\0\x0eruntime-failed\x01\x11\
\0\x07timeout\0\0\x11resource-exceeded\0\0\x08internal\x01s\0\x04\0\x05error\x03\
\0\x15\x01q\x04\x0cstdout-chunk\x01\x07\0\x0cstderr-chunk\x01\x07\0\x08finished\x01\
\x14\0\x06failed\x01\x16\0\x04\0\x0aexec-event\x03\0\x17\x04\0\x16golem:exec/typ\
es@1.0.0\x05\0\x02\x03\0\0\x08language\x02\x03\0\0\x04file\x02\x03\0\0\x06limits\
\x02\x03\0\0\x0bexec-result\x02\x03\0\0\x05error\x02\x03\0\0\x0aexec-event\x01B\x1b\
\x02\x03\x02\x01\x01\x04\0\x08language\x03\0\0\x02\x03\x02\x01\x02\x04\0\x04file\
\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x06limits\x03\0\x04\x02\x03\x02\x01\x04\x04\
\0\x0bexec-result\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x05error\x03\0\x08\x02\x03\
\x02\x01\x06\x04\0\x0aexec-event\x03\0\x0a\x01p\x03\x01ks\x01ps\x01o\x02ss\x01p\x0f\
\x01k\x05\x01j\x01\x07\x01\x09\x01@\x06\x04lang\x01\x05files\x0c\x05stdin\x0d\x04\
args\x0e\x03env\x10\x0bconstraints\x11\0\x12\x04\0\x03run\x01\x13\x01p}\x01f\x01\
\x14\x01k\x15\x01f\x01\x0b\x01@\x06\x04lang\x01\x05files\x0c\x05stdin\x16\x04arg\
s\x0e\x03env\x10\x0bconstraints\x11\0\x17\x04\0\x0drun-streaming\x01\x18\x04\0\x19\
golem:exec/executor@1.0.0\x05\x07\x01B,\x02\x03\x02\x01\x01\x04\0\x08language\x03\
\0\0\x02\x03\x02\x01\x02\x04\0\x04file\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x06li\
mits\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0bexec-result\x03\0\x06\x02\x03\x02\x01\
\x05\x04\0\x05error\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x0aexec-event\x03\0\x0a\x01\
y\x04\0\x0esession-handle\x03\0\x0c\x01j\x01\x0d\x01\x09\x01@\x01\x04lang\x01\0\x0e\
\x04\0\x06create\x01\x0f\x01j\0\x01\x09\x01@\x02\x07session\x0d\x04file\x03\0\x10\
\x04\0\x06upload\x01\x11\x01ps\x01ks\x01o\x02ss\x01p\x14\x01k\x05\x01j\x01\x07\x01\
\x09\x01@\x06\x07session\x0d\x0aentrypoints\x04args\x12\x05stdin\x13\x03env\x15\x0b\
constraints\x16\0\x17\x04\0\x03run\x01\x18\x01p}\x01f\x01\x19\x01k\x1a\x01f\x01\x0b\
\x01@\x06\x07session\x0d\x0aentrypoints\x04args\x12\x05stdin\x1b\x03env\x15\x0bc\
onstraints\x16\0\x1c\x04\0\x0drun-streaming\x01\x1d\x01j\x01\x19\x01\x09\x01@\x02\
\x07session\x0d\x04paths\0\x1e\x04\0\x08download\x01\x1f\x01j\x01\x12\x01\x09\x01\
@\x02\x07session\x0d\x03dirs\0\x20\x04\0\x0alist-files\x01!\x01@\x02\x07session\x0d\
\x04paths\0\x10\x04\0\x0fset-working-dir\x01\"\x01@\x01\x07session\x0d\x01\0\x04\
\0\x05close\x01#\x04\0\x18golem:exec/session@1.0.0\x05\x08\x04\0\x1dgolem:exec/e\
xec-library@1.0.0\x04\0\x0b\x12\x01\0\x0cexec-library\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.230.0\x10wit-bindgen-rust\x060.42.1";

                    #[inline(never)]
                    #[doc(hidden)]
                    pub fn __link_custom_section_describing_imports() {
                      wit_bindgen::rt::maybe_link_cabi_realloc();
                    }
                    
