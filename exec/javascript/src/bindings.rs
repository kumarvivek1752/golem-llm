// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * generate_unused_types
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod golem {
        pub mod exec {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum LanguageKind {
                    Javascript,
                    Python,
                }
                impl ::core::fmt::Debug for LanguageKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            LanguageKind::Javascript => {
                                f.debug_tuple("LanguageKind::Javascript").finish()
                            }
                            LanguageKind::Python => {
                                f.debug_tuple("LanguageKind::Python").finish()
                            }
                        }
                    }
                }
                impl LanguageKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> LanguageKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => LanguageKind::Javascript,
                            1 => LanguageKind::Python,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Supported language types and optional version
                #[derive(Clone)]
                pub struct Language {
                    pub kind: LanguageKind,
                    pub version: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for Language {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Language")
                            .field("kind", &self.kind)
                            .field("version", &self.version)
                            .finish()
                    }
                }
                /// Supported encodings for file contents
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum Encoding {
                    Utf8,
                    Base64,
                    Hex,
                }
                impl ::core::fmt::Debug for Encoding {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Encoding::Utf8 => f.debug_tuple("Encoding::Utf8").finish(),
                            Encoding::Base64 => {
                                f.debug_tuple("Encoding::Base64").finish()
                            }
                            Encoding::Hex => f.debug_tuple("Encoding::Hex").finish(),
                        }
                    }
                }
                impl Encoding {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Encoding {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => Encoding::Utf8,
                            1 => Encoding::Base64,
                            2 => Encoding::Hex,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Code file to execute
                #[derive(Clone)]
                pub struct File {
                    pub name: _rt::String,
                    pub content: _rt::Vec<u8>,
                    pub encoding: Option<Encoding>,
                }
                impl ::core::fmt::Debug for File {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("File")
                            .field("name", &self.name)
                            .field("content", &self.content)
                            .field("encoding", &self.encoding)
                            .finish()
                    }
                }
                /// Resource limits and execution constraints
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Limits {
                    pub time_ms: Option<u64>,
                    pub memory_bytes: Option<u64>,
                    pub file_size_bytes: Option<u64>,
                    pub max_processes: Option<u32>,
                }
                impl ::core::fmt::Debug for Limits {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Limits")
                            .field("time-ms", &self.time_ms)
                            .field("memory-bytes", &self.memory_bytes)
                            .field("file-size-bytes", &self.file_size_bytes)
                            .field("max-processes", &self.max_processes)
                            .finish()
                    }
                }
                /// Execution outcome per stage
                #[derive(Clone)]
                pub struct StageResult {
                    pub stdout: _rt::String,
                    pub stderr: _rt::String,
                    pub exit_code: Option<i32>,
                    pub signal: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for StageResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("StageResult")
                            .field("stdout", &self.stdout)
                            .field("stderr", &self.stderr)
                            .field("exit-code", &self.exit_code)
                            .field("signal", &self.signal)
                            .finish()
                    }
                }
                /// Complete execution exec-result
                #[derive(Clone)]
                pub struct ExecResult {
                    pub compile: Option<StageResult>,
                    pub run: StageResult,
                    pub time_ms: Option<u64>,
                    pub memory_bytes: Option<u64>,
                }
                impl ::core::fmt::Debug for ExecResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ExecResult")
                            .field("compile", &self.compile)
                            .field("run", &self.run)
                            .field("time-ms", &self.time_ms)
                            .field("memory-bytes", &self.memory_bytes)
                            .finish()
                    }
                }
                /// Execution error types
                #[derive(Clone)]
                pub enum Error {
                    UnsupportedLanguage,
                    CompilationFailed(StageResult),
                    RuntimeFailed(StageResult),
                    Timeout,
                    ResourceExceeded,
                    Internal(_rt::String),
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Error::UnsupportedLanguage => {
                                f.debug_tuple("Error::UnsupportedLanguage").finish()
                            }
                            Error::CompilationFailed(e) => {
                                f.debug_tuple("Error::CompilationFailed").field(e).finish()
                            }
                            Error::RuntimeFailed(e) => {
                                f.debug_tuple("Error::RuntimeFailed").field(e).finish()
                            }
                            Error::Timeout => f.debug_tuple("Error::Timeout").finish(),
                            Error::ResourceExceeded => {
                                f.debug_tuple("Error::ResourceExceeded").finish()
                            }
                            Error::Internal(e) => {
                                f.debug_tuple("Error::Internal").field(e).finish()
                            }
                        }
                    }
                }
                /// Streamed event output during execution
                #[derive(Clone)]
                pub enum ExecEvent {
                    StdoutChunk(_rt::Vec<u8>),
                    StderrChunk(_rt::Vec<u8>),
                    Finished(ExecResult),
                    Failed(Error),
                }
                impl ::core::fmt::Debug for ExecEvent {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ExecEvent::StdoutChunk(e) => {
                                f.debug_tuple("ExecEvent::StdoutChunk").field(e).finish()
                            }
                            ExecEvent::StderrChunk(e) => {
                                f.debug_tuple("ExecEvent::StderrChunk").field(e).finish()
                            }
                            ExecEvent::Finished(e) => {
                                f.debug_tuple("ExecEvent::Finished").field(e).finish()
                            }
                            ExecEvent::Failed(e) => {
                                f.debug_tuple("ExecEvent::Failed").field(e).finish()
                            }
                        }
                    }
                }
                #[doc(hidden)]
                macro_rules! __export_golem_exec_types_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_exec_types_1_0_0_cabi;
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_exec_library_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::golem::exec::types::__export_golem_exec_types_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::exec::types);
    };
}
#[doc(inline)]
pub(crate) use __export_exec_library_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:golem:exec-javascript@1.0.0:exec-library:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 751] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xec\x04\x01A\x02\x01\
A\x02\x01B\x19\x01m\x02\x0ajavascript\x06python\x04\0\x0dlanguage-kind\x03\0\0\x01\
ks\x01r\x02\x04kind\x01\x07version\x02\x04\0\x08language\x03\0\x03\x01m\x03\x04u\
tf8\x06base64\x03hex\x04\0\x08encoding\x03\0\x05\x01p}\x01k\x06\x01r\x03\x04name\
s\x07content\x07\x08encoding\x08\x04\0\x04file\x03\0\x09\x01kw\x01ky\x01r\x04\x07\
time-ms\x0b\x0cmemory-bytes\x0b\x0ffile-size-bytes\x0b\x0dmax-processes\x0c\x04\0\
\x06limits\x03\0\x0d\x01kz\x01r\x04\x06stdouts\x06stderrs\x09exit-code\x0f\x06si\
gnal\x02\x04\0\x0cstage-result\x03\0\x10\x01k\x11\x01r\x04\x07compile\x12\x03run\
\x11\x07time-ms\x0b\x0cmemory-bytes\x0b\x04\0\x0bexec-result\x03\0\x13\x01q\x06\x14\
unsupported-language\0\0\x12compilation-failed\x01\x11\0\x0eruntime-failed\x01\x11\
\0\x07timeout\0\0\x11resource-exceeded\0\0\x08internal\x01s\0\x04\0\x05error\x03\
\0\x15\x01q\x04\x0cstdout-chunk\x01\x07\0\x0cstderr-chunk\x01\x07\0\x08finished\x01\
\x14\0\x06failed\x01\x16\0\x04\0\x0aexec-event\x03\0\x17\x04\0\x16golem:exec/typ\
es@1.0.0\x05\0\x04\0(golem:exec-javascript/exec-library@1.0.0\x04\0\x0b\x12\x01\0\
\x0cexec-library\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-componen\
t\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
